import {
  MtxDialog,
  MtxDialogModule
} from "./chunk-FEJHA6X3.js";
import {
  MtxIsTemplateRefPipe,
  MtxPipesModule,
  MtxToObservablePipe
} from "./chunk-DUWU3IMR.js";
import {
  MatSort,
  MatSortHeader,
  MatSortModule
} from "./chunk-FTYYQO3I.js";
import {
  MatCell,
  MatCellDef,
  MatColumnDef,
  MatFooterCell,
  MatFooterCellDef,
  MatFooterRow,
  MatFooterRowDef,
  MatHeaderCell,
  MatHeaderCellDef,
  MatHeaderRow,
  MatHeaderRowDef,
  MatRow,
  MatRowDef,
  MatTable,
  MatTableDataSource,
  MatTableModule
} from "./chunk-DWPSSOJU.js";
import "./chunk-YRGSMVLQ.js";
import {
  MatProgressBar,
  MatProgressBarModule
} from "./chunk-XIIXAE4T.js";
import "./chunk-FS44UC3G.js";
import "./chunk-X6AZ7VWY.js";
import {
  MatIcon,
  MatIconModule
} from "./chunk-FHX5LAOA.js";
import "./chunk-M7P2K6UT.js";
import "./chunk-NTYLKV6C.js";
import {
  MatMenu,
  MatMenuItem,
  MatMenuModule,
  MatMenuTrigger
} from "./chunk-DRNWCNM3.js";
import {
  MatPaginator,
  MatPaginatorModule
} from "./chunk-AGWAMC72.js";
import {
  MatTooltipModule
} from "./chunk-UVO7J22L.js";
import {
  MatSelectModule
} from "./chunk-VM3RIDWB.js";
import {
  MatFormFieldModule
} from "./chunk-U4WUX73G.js";
import "./chunk-CRFEUD44.js";
import {
  MatChip,
  MatChipListbox,
  MatChipsModule
} from "./chunk-FDWEOAJK.js";
import "./chunk-BUODDSMA.js";
import "./chunk-PDT2INH5.js";
import {
  MatCheckbox,
  MatCheckboxModule
} from "./chunk-HCOHMZSA.js";
import "./chunk-53W4PNKK.js";
import "./chunk-LCG7XJKE.js";
import {
  MatTooltip
} from "./chunk-BIIEJTHI.js";
import "./chunk-NJS35E3Q.js";
import "./chunk-XA3EVXH3.js";
import "./chunk-5JG26RIF.js";
import "./chunk-3ZNKIVOX.js";
import "./chunk-ZRGC465N.js";
import "./chunk-4VSTA2RQ.js";
import "./chunk-RFR6EMPK.js";
import "./chunk-IHNR7OQO.js";
import {
  FormsModule,
  NgControlStatus,
  NgModel
} from "./chunk-ZYYYR2L4.js";
import {
  MatBadge,
  MatBadgeModule
} from "./chunk-WLHXVHVJ.js";
import {
  MatButton,
  MatButtonModule,
  MatIconButton
} from "./chunk-NA7PBFX6.js";
import "./chunk-YIF4T2TR.js";
import "./chunk-EBZ3PI6G.js";
import "./chunk-MKT2JYIF.js";
import "./chunk-4HFP2B2Z.js";
import "./chunk-WYFSJBQU.js";
import "./chunk-OX3NRC6A.js";
import "./chunk-6HJBXO2Q.js";
import {
  Overlay,
  OverlayModule
} from "./chunk-5X3YISR3.js";
import {
  ComponentPortal
} from "./chunk-E7NPFLEN.js";
import "./chunk-VENV3F3G.js";
import {
  coerceCssPixelValue
} from "./chunk-L2BZS5YT.js";
import "./chunk-4MZFUHHW.js";
import {
  MatCommonModule
} from "./chunk-EUCP2ZY2.js";
import "./chunk-AJKRHC55.js";
import "./chunk-GIJAI27L.js";
import {
  CdkDrag,
  CdkDropList,
  DragDropModule,
  moveItemInArray
} from "./chunk-7KC5GDTR.js";
import {
  _IdGenerator
} from "./chunk-YD3JPWO3.js";
import "./chunk-2ZKSKDON.js";
import {
  CdkColumnDef,
  CdkTable
} from "./chunk-OCC7QWA6.js";
import "./chunk-TCRIAERE.js";
import "./chunk-ZZTSUEW6.js";
import "./chunk-VFYKDPTI.js";
import "./chunk-7UJZXIJQ.js";
import "./chunk-IP7SSTAP.js";
import "./chunk-WB2HPCD2.js";
import "./chunk-TR37UYJX.js";
import "./chunk-J7QA3RMN.js";
import {
  AsyncPipe,
  CommonModule,
  CurrencyPipe,
  DatePipe,
  DecimalPipe,
  NgTemplateOutlet,
  PercentPipe
} from "./chunk-7NOA7DFH.js";
import {
  SelectionModel
} from "./chunk-QNTNQXBT.js";
import {
  ESCAPE
} from "./chunk-2SF2BFR3.js";
import "./chunk-SOWEEQXE.js";
import {
  Directionality
} from "./chunk-IET25UKP.js";
import "./chunk-EILSSNDT.js";
import "./chunk-OUSM42MY.js";
import {
  ANIMATION_MODULE_TYPE,
  CSP_NONCE,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ContentChildren,
  DOCUMENT,
  Directive,
  ElementRef,
  EventEmitter,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  KeyValueDiffers,
  NgModule,
  NgZone,
  Output,
  Pipe,
  Renderer2,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation,
  booleanAttribute,
  inject,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵconditionalBranchCreate,
  ɵɵconditionalCreate,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdomElement,
  ɵɵelement,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind3,
  ɵɵpipeBind4,
  ɵɵpipeBindV,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-TGP6U4PS.js";
import {
  isObservable,
  merge
} from "./chunk-MY7C4QNH.js";
import "./chunk-H6VVMQMC.js";
import {
  Subject,
  combineLatest,
  distinctUntilChanged,
  filter,
  mapTo,
  pairwise,
  share,
  skip,
  startWith,
  take,
  takeUntil
} from "./chunk-KEQKGBJ6.js";
import {
  Observable,
  map
} from "./chunk-HOFLPY52.js";
import "./chunk-PEHFQLBM.js";

// node_modules/@ng-matero/extensions/fesm2022/mtxColumnResize.mjs
var HEADER_CELL_SELECTOR = ".cdk-header-cell, .mat-header-cell";
var HEADER_ROW_SELECTOR = ".cdk-header-row, .mat-header-row";
var RESIZE_OVERLAY_SELECTOR = ".mat-column-resize-overlay-thumb";
function closest(element, selector) {
  if (!(element instanceof Node)) {
    return null;
  }
  let curr = element;
  while (curr != null && !(curr instanceof Element)) {
    curr = curr.parentNode;
  }
  return curr?.closest(selector) ?? null;
}
var HOVER_OR_ACTIVE_CLASS = "cdk-column-resize-hover-or-active";
var WITH_RESIZED_COLUMN_CLASS = "cdk-column-resize-with-resized-column";
var COLUMN_RESIZE_OPTIONS = new InjectionToken("CdkColumnResizeOptions");
var _ColumnResize = class _ColumnResize {
  constructor() {
    this._renderer = inject(Renderer2);
    this.destroyed = new Subject();
    this.selectorId = inject(_IdGenerator).getId("cdk-column-resize-");
    this._flushPending = false;
    this.liveResizeUpdates = inject(COLUMN_RESIZE_OPTIONS, {
      optional: true
    })?.liveResizeUpdates ?? true;
  }
  ngAfterViewInit() {
    this.elementRef.nativeElement.classList.add(this.getUniqueCssClass());
    this._listenForRowHoverEvents();
    this._listenForResizeActivity();
    this._listenForHoverActivity();
  }
  ngOnDestroy() {
    this._eventCleanups?.forEach((cleanup) => cleanup());
    this.destroyed.next();
    this.destroyed.complete();
  }
  /** Gets the unique CSS class name for this table instance. */
  getUniqueCssClass() {
    return this.selectorId;
  }
  /** Gets the ID for this table used for column size persistance. */
  getTableId() {
    return String(this.elementRef.nativeElement.id);
  }
  /** Called when a column in the table is resized. Applies a css class to the table element. */
  setResized() {
    this.elementRef.nativeElement.classList.add(WITH_RESIZED_COLUMN_CLASS);
  }
  _listenForRowHoverEvents() {
    this.ngZone.runOutsideAngular(() => {
      const element = this.elementRef.nativeElement;
      this._eventCleanups = [this._renderer.listen(element, "mouseover", (event) => {
        this.eventDispatcher.headerCellHovered.next(closest(event.target, HEADER_CELL_SELECTOR));
      }), this._renderer.listen(element, "mouseleave", (event) => {
        if (event.relatedTarget && !event.relatedTarget.matches(RESIZE_OVERLAY_SELECTOR)) {
          this.eventDispatcher.headerCellHovered.next(null);
        }
      })];
    });
  }
  _listenForResizeActivity() {
    merge(this.eventDispatcher.overlayHandleActiveForCell.pipe(mapTo(void 0)), this.notifier.triggerResize.pipe(mapTo(void 0)), this.notifier.resizeCompleted.pipe(mapTo(void 0))).pipe(take(1), takeUntil(this.destroyed)).subscribe(() => {
      this.setResized();
    });
  }
  _listenForHoverActivity() {
    this.eventDispatcher.headerRowHoveredOrActiveDistinct.pipe(startWith(null), pairwise(), takeUntil(this.destroyed)).subscribe(([previousRow, hoveredRow]) => {
      if (hoveredRow) {
        hoveredRow.classList.add(HOVER_OR_ACTIVE_CLASS);
      }
      if (previousRow) {
        previousRow.classList.remove(HOVER_OR_ACTIVE_CLASS);
      }
    });
  }
};
_ColumnResize.ɵfac = function ColumnResize_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ColumnResize)();
};
_ColumnResize.ɵdir = ɵɵdefineDirective({
  type: _ColumnResize,
  inputs: {
    liveResizeUpdates: "liveResizeUpdates"
  }
});
var ColumnResize = _ColumnResize;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResize, [{
    type: Directive
  }], null, {
    liveResizeUpdates: [{
      type: Input
    }]
  });
})();
var _ColumnResizeNotifierSource = class _ColumnResizeNotifierSource {
  constructor() {
    this.resizeCanceled = new Subject();
    this.resizeCompleted = new Subject();
    this.triggerResize = new Subject();
  }
};
_ColumnResizeNotifierSource.ɵfac = function ColumnResizeNotifierSource_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ColumnResizeNotifierSource)();
};
_ColumnResizeNotifierSource.ɵprov = ɵɵdefineInjectable({
  token: _ColumnResizeNotifierSource,
  factory: _ColumnResizeNotifierSource.ɵfac
});
var ColumnResizeNotifierSource = _ColumnResizeNotifierSource;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResizeNotifierSource, [{
    type: Injectable
  }], null, null);
})();
var _ColumnResizeNotifier = class _ColumnResizeNotifier {
  constructor() {
    this._source = inject(ColumnResizeNotifierSource);
    this.resizeCompleted = this._source.resizeCompleted;
  }
  /** Instantly resizes the specified column. */
  resize(columnId, size) {
    this._source.triggerResize.next({
      columnId,
      size,
      completeImmediately: true,
      isStickyColumn: true
    });
  }
};
_ColumnResizeNotifier.ɵfac = function ColumnResizeNotifier_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ColumnResizeNotifier)();
};
_ColumnResizeNotifier.ɵprov = ɵɵdefineInjectable({
  token: _ColumnResizeNotifier,
  factory: _ColumnResizeNotifier.ɵfac
});
var ColumnResizeNotifier = _ColumnResizeNotifier;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResizeNotifier, [{
    type: Injectable
  }], null, null);
})();
var _HeaderRowEventDispatcher = class _HeaderRowEventDispatcher {
  constructor() {
    this._ngZone = inject(NgZone);
    this.headerCellHovered = new Subject();
    this.overlayHandleActiveForCell = new Subject();
    this.headerCellHoveredDistinct = this.headerCellHovered.pipe(distinctUntilChanged(), share());
    this.headerRowHoveredOrActiveDistinct = combineLatest([this.headerCellHoveredDistinct.pipe(map((cell) => closest(cell, HEADER_ROW_SELECTOR)), startWith(null), distinctUntilChanged()), this.overlayHandleActiveForCell.pipe(map((cell) => closest(cell, HEADER_ROW_SELECTOR)), startWith(null), distinctUntilChanged())]).pipe(
      skip(1),
      // Ignore initial [null, null] emission.
      map(([hovered, active]) => active || hovered),
      distinctUntilChanged(),
      share()
    );
    this._headerRowHoveredOrActiveDistinctReenterZone = this.headerRowHoveredOrActiveDistinct.pipe(this._enterZone(), share());
    this._lastSeenRow = null;
    this._lastSeenRowHover = null;
  }
  /**
   * Emits whether the specified row should show its overlay controls.
   * Emission occurs within the NgZone.
   */
  resizeOverlayVisibleForHeaderRow(row) {
    if (row !== this._lastSeenRow) {
      this._lastSeenRow = row;
      this._lastSeenRowHover = this._headerRowHoveredOrActiveDistinctReenterZone.pipe(map((hoveredRow) => hoveredRow === row), distinctUntilChanged(), share());
    }
    return this._lastSeenRowHover;
  }
  _enterZone() {
    return (source) => new Observable((observer) => source.subscribe({
      next: (value) => this._ngZone.run(() => observer.next(value)),
      error: (err) => observer.error(err),
      complete: () => observer.complete()
    }));
  }
};
_HeaderRowEventDispatcher.ɵfac = function HeaderRowEventDispatcher_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _HeaderRowEventDispatcher)();
};
_HeaderRowEventDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _HeaderRowEventDispatcher,
  factory: _HeaderRowEventDispatcher.ɵfac
});
var HeaderRowEventDispatcher = _HeaderRowEventDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderRowEventDispatcher, [{
    type: Injectable
  }], null, null);
})();
var _Schedule = class {
  constructor() {
    this.tasks = [];
    this.endTasks = [];
  }
};
var _COALESCED_STYLE_SCHEDULER = new InjectionToken("_COALESCED_STYLE_SCHEDULER");
var __CoalescedStyleScheduler = class __CoalescedStyleScheduler {
  constructor() {
    this._currentSchedule = null;
    this._ngZone = inject(NgZone);
  }
  /**
   * Schedules the specified task to run at the end of the current VM turn.
   */
  schedule(task) {
    this._createScheduleIfNeeded();
    this._currentSchedule.tasks.push(task);
  }
  /**
   * Schedules the specified task to run after other scheduled tasks at the end of the current
   * VM turn.
   */
  scheduleEnd(task) {
    this._createScheduleIfNeeded();
    this._currentSchedule.endTasks.push(task);
  }
  _createScheduleIfNeeded() {
    if (this._currentSchedule) {
      return;
    }
    this._currentSchedule = new _Schedule();
    this._ngZone.runOutsideAngular(() => (
      // TODO(mmalerba): Scheduling this using something that runs less frequently
      //  (e.g. requestAnimationFrame, setTimeout, etc.) causes noticeable jank with the column
      //  resizer. We should audit the usages of schedule / scheduleEnd in that component and see
      //  if we can refactor it so that we don't need to flush the tasks quite so frequently.
      queueMicrotask(() => {
        while (this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length) {
          const schedule = this._currentSchedule;
          this._currentSchedule = new _Schedule();
          for (const task of schedule.tasks) {
            task();
          }
          for (const task of schedule.endTasks) {
            task();
          }
        }
        this._currentSchedule = null;
      })
    ));
  }
};
__CoalescedStyleScheduler.ɵfac = function _CoalescedStyleScheduler_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || __CoalescedStyleScheduler)();
};
__CoalescedStyleScheduler.ɵprov = ɵɵdefineInjectable({
  token: __CoalescedStyleScheduler,
  factory: __CoalescedStyleScheduler.ɵfac
});
var _CoalescedStyleScheduler = __CoalescedStyleScheduler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CoalescedStyleScheduler, [{
    type: Injectable
  }], null, null);
})();
var _ResizeStrategy = class _ResizeStrategy {
  constructor() {
    this._pendingResizeDelta = null;
  }
  /** Adjusts the width of the table element by the specified delta. */
  updateTableWidthAndStickyColumns(delta) {
    if (this._pendingResizeDelta === null) {
      const tableElement = this.columnResize.elementRef.nativeElement;
      const tableWidth = this.getElementWidth(tableElement);
      this.styleScheduler.schedule(() => {
        tableElement.style.width = coerceCssPixelValue(tableWidth + this._pendingResizeDelta);
        this._pendingResizeDelta = null;
      });
      this.styleScheduler.scheduleEnd(() => {
        this.table.updateStickyColumnStyles();
      });
    }
    this._pendingResizeDelta = (this._pendingResizeDelta ?? 0) + delta;
  }
  /** Gets the style.width pixels on the specified element if present, otherwise its offsetWidth. */
  getElementWidth(element) {
    return coercePixelsFromCssValue(element.style.width) || element.offsetWidth;
  }
};
_ResizeStrategy.ɵfac = function ResizeStrategy_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ResizeStrategy)();
};
_ResizeStrategy.ɵprov = ɵɵdefineInjectable({
  token: _ResizeStrategy,
  factory: _ResizeStrategy.ɵfac
});
var ResizeStrategy = _ResizeStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizeStrategy, [{
    type: Injectable
  }], null, null);
})();
var _TableLayoutFixedResizeStrategy = class _TableLayoutFixedResizeStrategy extends ResizeStrategy {
  constructor() {
    super(...arguments);
    this.columnResize = inject(ColumnResize);
    this.styleScheduler = inject(_COALESCED_STYLE_SCHEDULER);
    this.table = inject(CdkTable);
  }
  applyColumnSize(_, columnHeader, sizeInPx, previousSizeInPx) {
    const delta = sizeInPx - (previousSizeInPx ?? this.getElementWidth(columnHeader));
    if (delta === 0) {
      return;
    }
    this.styleScheduler.schedule(() => {
      columnHeader.style.width = coerceCssPixelValue(sizeInPx);
    });
    this.updateTableWidthAndStickyColumns(delta);
  }
  applyMinColumnSize(_, columnHeader, sizeInPx) {
    const currentWidth = this.getElementWidth(columnHeader);
    const newWidth = Math.max(currentWidth, sizeInPx);
    this.applyColumnSize(_, columnHeader, newWidth, currentWidth);
  }
  applyMaxColumnSize(_, columnHeader, sizeInPx) {
    const currentWidth = this.getElementWidth(columnHeader);
    const newWidth = Math.min(currentWidth, sizeInPx);
    this.applyColumnSize(_, columnHeader, newWidth, currentWidth);
  }
};
_TableLayoutFixedResizeStrategy.ɵfac = /* @__PURE__ */ (() => {
  let ɵTableLayoutFixedResizeStrategy_BaseFactory;
  return function TableLayoutFixedResizeStrategy_Factory(__ngFactoryType__) {
    return (ɵTableLayoutFixedResizeStrategy_BaseFactory || (ɵTableLayoutFixedResizeStrategy_BaseFactory = ɵɵgetInheritedFactory(_TableLayoutFixedResizeStrategy)))(__ngFactoryType__ || _TableLayoutFixedResizeStrategy);
  };
})();
_TableLayoutFixedResizeStrategy.ɵprov = ɵɵdefineInjectable({
  token: _TableLayoutFixedResizeStrategy,
  factory: _TableLayoutFixedResizeStrategy.ɵfac
});
var TableLayoutFixedResizeStrategy = _TableLayoutFixedResizeStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableLayoutFixedResizeStrategy, [{
    type: Injectable
  }], null, null);
})();
var _CdkFlexTableResizeStrategy = class _CdkFlexTableResizeStrategy extends ResizeStrategy {
  constructor() {
    super(...arguments);
    this.columnResize = inject(ColumnResize);
    this.styleScheduler = inject(_COALESCED_STYLE_SCHEDULER);
    this.table = inject(CdkTable);
    this._nonce = inject(CSP_NONCE, {
      optional: true
    });
    this._document = inject(DOCUMENT);
    this._columnIndexes = /* @__PURE__ */ new Map();
    this._columnProperties = /* @__PURE__ */ new Map();
    this._indexSequence = 0;
    this.defaultMinSize = 0;
    this.defaultMaxSize = Number.MAX_SAFE_INTEGER;
  }
  applyColumnSize(cssFriendlyColumnName, columnHeader, sizeInPx, previousSizeInPx) {
    const delta = sizeInPx - (previousSizeInPx ?? (this._getAppliedWidth(cssFriendlyColumnName) || columnHeader.offsetWidth));
    if (delta === 0) {
      return;
    }
    const cssSize = coerceCssPixelValue(sizeInPx);
    this._applyProperty(cssFriendlyColumnName, "flex", `0 0.01 ${cssSize}`);
    this.updateTableWidthAndStickyColumns(delta);
  }
  applyMinColumnSize(cssFriendlyColumnName, _, sizeInPx) {
    const cssSize = coerceCssPixelValue(sizeInPx);
    this._applyProperty(cssFriendlyColumnName, "min-width", cssSize, sizeInPx !== this.defaultMinSize);
    this.updateTableWidthAndStickyColumns(0);
  }
  applyMaxColumnSize(cssFriendlyColumnName, _, sizeInPx) {
    const cssSize = coerceCssPixelValue(sizeInPx);
    this._applyProperty(cssFriendlyColumnName, "max-width", cssSize, sizeInPx !== this.defaultMaxSize);
    this.updateTableWidthAndStickyColumns(0);
  }
  getColumnCssClass(cssFriendlyColumnName) {
    return `cdk-column-${cssFriendlyColumnName}`;
  }
  ngOnDestroy() {
    this._styleElement?.remove();
    this._styleElement = void 0;
  }
  _getPropertyValue(cssFriendlyColumnName, key) {
    const properties = this._getColumnPropertiesMap(cssFriendlyColumnName);
    return properties.get(key);
  }
  _getAppliedWidth(cssFriendslyColumnName) {
    return coercePixelsFromFlexValue(this._getPropertyValue(cssFriendslyColumnName, "flex"));
  }
  _applyProperty(cssFriendlyColumnName, key, value, enable = true) {
    const properties = this._getColumnPropertiesMap(cssFriendlyColumnName);
    this.styleScheduler.schedule(() => {
      if (enable) {
        properties.set(key, value);
      } else {
        properties.delete(key);
      }
      this._applySizeCss(cssFriendlyColumnName);
    });
  }
  _getStyleSheet() {
    if (!this._styleElement) {
      this._styleElement = this._document.createElement("style");
      if (this._nonce) {
        this._styleElement.setAttribute("nonce", this._nonce);
      }
      this._styleElement.appendChild(this._document.createTextNode(""));
      this._document.head.appendChild(this._styleElement);
    }
    return this._styleElement.sheet;
  }
  _getColumnPropertiesMap(cssFriendlyColumnName) {
    let properties = this._columnProperties.get(cssFriendlyColumnName);
    if (properties === void 0) {
      properties = /* @__PURE__ */ new Map();
      this._columnProperties.set(cssFriendlyColumnName, properties);
    }
    return properties;
  }
  _applySizeCss(cssFriendlyColumnName) {
    const properties = this._getColumnPropertiesMap(cssFriendlyColumnName);
    const propertyKeys = Array.from(properties.keys());
    let index = this._columnIndexes.get(cssFriendlyColumnName);
    if (index === void 0) {
      if (!propertyKeys.length) {
        return;
      }
      index = this._indexSequence++;
      this._columnIndexes.set(cssFriendlyColumnName, index);
    } else {
      this._getStyleSheet().deleteRule(index);
    }
    const columnClassName = this.getColumnCssClass(cssFriendlyColumnName);
    const tableClassName = this.columnResize.getUniqueCssClass();
    const selector = `.${tableClassName} .${columnClassName}`;
    const body = propertyKeys.map((key) => `${key}:${properties.get(key)}`).join(";");
    this._getStyleSheet().insertRule(`${selector} {${body}}`, index);
  }
};
_CdkFlexTableResizeStrategy.ɵfac = /* @__PURE__ */ (() => {
  let ɵCdkFlexTableResizeStrategy_BaseFactory;
  return function CdkFlexTableResizeStrategy_Factory(__ngFactoryType__) {
    return (ɵCdkFlexTableResizeStrategy_BaseFactory || (ɵCdkFlexTableResizeStrategy_BaseFactory = ɵɵgetInheritedFactory(_CdkFlexTableResizeStrategy)))(__ngFactoryType__ || _CdkFlexTableResizeStrategy);
  };
})();
_CdkFlexTableResizeStrategy.ɵprov = ɵɵdefineInjectable({
  token: _CdkFlexTableResizeStrategy,
  factory: _CdkFlexTableResizeStrategy.ɵfac
});
var CdkFlexTableResizeStrategy = _CdkFlexTableResizeStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFlexTableResizeStrategy, [{
    type: Injectable
  }], null, null);
})();
function coercePixelsFromCssValue(cssValue) {
  return Number(cssValue.match(/(\d+)px/)?.[1]);
}
function coercePixelsFromFlexValue(flexValue) {
  return Number(flexValue?.match(/0 0\.01 (\d+)px/)?.[1]);
}
var TABLE_LAYOUT_FIXED_RESIZE_STRATEGY_PROVIDER = {
  provide: ResizeStrategy,
  useClass: TableLayoutFixedResizeStrategy
};
var FLEX_RESIZE_STRATEGY_PROVIDER = {
  provide: ResizeStrategy,
  useClass: CdkFlexTableResizeStrategy
};
var PROVIDERS = [ColumnResizeNotifier, HeaderRowEventDispatcher, ColumnResizeNotifierSource, {
  provide: _COALESCED_STYLE_SCHEDULER,
  useClass: _CoalescedStyleScheduler
}];
var TABLE_PROVIDERS = [...PROVIDERS, TABLE_LAYOUT_FIXED_RESIZE_STRATEGY_PROVIDER];
var FLEX_PROVIDERS = [...PROVIDERS, FLEX_RESIZE_STRATEGY_PROVIDER];
var _CdkColumnResize = class _CdkColumnResize extends ColumnResize {
  constructor() {
    super(...arguments);
    this.columnResizeNotifier = inject(ColumnResizeNotifier);
    this.elementRef = inject(ElementRef);
    this.eventDispatcher = inject(HeaderRowEventDispatcher);
    this.ngZone = inject(NgZone);
    this.notifier = inject(ColumnResizeNotifierSource);
    this.table = inject(CdkTable);
  }
};
_CdkColumnResize.ɵfac = /* @__PURE__ */ (() => {
  let ɵCdkColumnResize_BaseFactory;
  return function CdkColumnResize_Factory(__ngFactoryType__) {
    return (ɵCdkColumnResize_BaseFactory || (ɵCdkColumnResize_BaseFactory = ɵɵgetInheritedFactory(_CdkColumnResize)))(__ngFactoryType__ || _CdkColumnResize);
  };
})();
_CdkColumnResize.ɵdir = ɵɵdefineDirective({
  type: _CdkColumnResize,
  selectors: [["table", "cdk-table", "", "columnResize", ""]],
  features: [ɵɵProvidersFeature([...TABLE_PROVIDERS, {
    provide: ColumnResize,
    useExisting: _CdkColumnResize
  }]), ɵɵInheritDefinitionFeature]
});
var CdkColumnResize = _CdkColumnResize;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkColumnResize, [{
    type: Directive,
    args: [{
      selector: "table[cdk-table][columnResize]",
      providers: [...TABLE_PROVIDERS, {
        provide: ColumnResize,
        useExisting: CdkColumnResize
      }]
    }]
  }], null, null);
})();
var _CdkColumnResizeFlex = class _CdkColumnResizeFlex extends ColumnResize {
  constructor() {
    super(...arguments);
    this.columnResizeNotifier = inject(ColumnResizeNotifier);
    this.elementRef = inject(ElementRef);
    this.eventDispatcher = inject(HeaderRowEventDispatcher);
    this.ngZone = inject(NgZone);
    this.notifier = inject(ColumnResizeNotifierSource);
    this.table = inject(CdkTable);
  }
};
_CdkColumnResizeFlex.ɵfac = /* @__PURE__ */ (() => {
  let ɵCdkColumnResizeFlex_BaseFactory;
  return function CdkColumnResizeFlex_Factory(__ngFactoryType__) {
    return (ɵCdkColumnResizeFlex_BaseFactory || (ɵCdkColumnResizeFlex_BaseFactory = ɵɵgetInheritedFactory(_CdkColumnResizeFlex)))(__ngFactoryType__ || _CdkColumnResizeFlex);
  };
})();
_CdkColumnResizeFlex.ɵdir = ɵɵdefineDirective({
  type: _CdkColumnResizeFlex,
  selectors: [["cdk-table", "columnResize", ""]],
  features: [ɵɵProvidersFeature([...FLEX_PROVIDERS, {
    provide: ColumnResize,
    useExisting: _CdkColumnResizeFlex
  }]), ɵɵInheritDefinitionFeature]
});
var CdkColumnResizeFlex = _CdkColumnResizeFlex;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkColumnResizeFlex, [{
    type: Directive,
    args: [{
      selector: "cdk-table[columnResize]",
      providers: [...FLEX_PROVIDERS, {
        provide: ColumnResize,
        useExisting: CdkColumnResizeFlex
      }]
    }]
  }], null, null);
})();
var _CdkColumnResizeModule = class _CdkColumnResizeModule {
};
_CdkColumnResizeModule.ɵfac = function CdkColumnResizeModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkColumnResizeModule)();
};
_CdkColumnResizeModule.ɵmod = ɵɵdefineNgModule({
  type: _CdkColumnResizeModule,
  imports: [CdkColumnResize, CdkColumnResizeFlex],
  exports: [CdkColumnResize, CdkColumnResizeFlex]
});
_CdkColumnResizeModule.ɵinj = ɵɵdefineInjector({});
var CdkColumnResizeModule = _CdkColumnResizeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkColumnResizeModule, [{
    type: NgModule,
    args: [{
      imports: [CdkColumnResize, CdkColumnResizeFlex],
      exports: [CdkColumnResize, CdkColumnResizeFlex]
    }]
  }], null, null);
})();
var _ColumnSizeStore = class _ColumnSizeStore {
};
_ColumnSizeStore.ɵfac = function ColumnSizeStore_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ColumnSizeStore)();
};
_ColumnSizeStore.ɵprov = ɵɵdefineInjectable({
  token: _ColumnSizeStore,
  factory: _ColumnSizeStore.ɵfac
});
var ColumnSizeStore = _ColumnSizeStore;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnSizeStore, [{
    type: Injectable
  }], null, null);
})();
var ResizeRef = class {
  constructor(origin, overlayRef, minWidthPx, maxWidthPx, liveUpdates = true) {
    this.origin = origin;
    this.overlayRef = overlayRef;
    this.minWidthPx = minWidthPx;
    this.maxWidthPx = maxWidthPx;
    this.liveUpdates = liveUpdates;
  }
};
var OVERLAY_ACTIVE_CLASS = "cdk-resizable-overlay-thumb-active";
var _Resizable = class _Resizable {
  constructor() {
    this.isResizable = true;
    this.minWidthPxInternal = 0;
    this.maxWidthPxInternal = Number.MAX_SAFE_INTEGER;
    this.destroyed = new Subject();
    this._viewInitialized = false;
    this._isDestroyed = false;
  }
  /** The minimum width to allow the column to be sized to. */
  get minWidthPx() {
    return this.minWidthPxInternal;
  }
  set minWidthPx(value) {
    if (value) {
      this.minWidthPxInternal = value;
    }
    this.columnResize.setResized();
    if (this.elementRef.nativeElement && this._viewInitialized) {
      this._applyMinWidthPx();
    }
  }
  /** The maximum width to allow the column to be sized to. */
  get maxWidthPx() {
    return this.maxWidthPxInternal;
  }
  set maxWidthPx(value) {
    if (value) {
      this.maxWidthPxInternal = value;
    }
    this.columnResize.setResized();
    if (this.elementRef.nativeElement && this._viewInitialized) {
      this._applyMaxWidthPx();
    }
  }
  ngAfterViewInit() {
    if (this.isResizable) {
      this._listenForRowHoverEvents();
      this._listenForResizeEvents();
      this._appendInlineHandle();
      this.styleScheduler.scheduleEnd(() => {
        if (this._isDestroyed) return;
        this._viewInitialized = true;
        this._applyMinWidthPx();
        this._applyMaxWidthPx();
      });
    }
  }
  ngOnDestroy() {
    this._isDestroyed = true;
    this.destroyed.next();
    this.destroyed.complete();
    this.inlineHandle?.remove();
    this.overlayRef?.dispose();
  }
  _createOverlayForHandle() {
    const isRtl = this.directionality.value === "rtl";
    const positionStrategy = this.overlay.position().flexibleConnectedTo(this.elementRef.nativeElement).withFlexibleDimensions(false).withGrowAfterOpen(false).withPush(false).withDefaultOffsetX(isRtl ? 1 : 0).withPositions([{
      originX: isRtl ? "start" : "end",
      originY: "top",
      overlayX: "center",
      overlayY: "top"
    }]);
    return this.overlay.create({
      // Always position the overlay based on left-indexed coordinates.
      direction: "ltr",
      disposeOnNavigation: true,
      positionStrategy,
      scrollStrategy: this.overlay.scrollStrategies.reposition(),
      width: "16px"
    });
  }
  _listenForRowHoverEvents() {
    const element = this.elementRef.nativeElement;
    const takeUntilDestroyed = takeUntil(this.destroyed);
    this.eventDispatcher.resizeOverlayVisibleForHeaderRow(closest(element, HEADER_ROW_SELECTOR)).pipe(takeUntilDestroyed).subscribe((hoveringRow) => {
      if (hoveringRow) {
        if (!this.overlayRef) {
          this.overlayRef = this._createOverlayForHandle();
        }
        this._showHandleOverlay();
      } else if (this.overlayRef) {
        this.overlayRef.detach();
      }
    });
  }
  _listenForResizeEvents() {
    const takeUntilDestroyed = takeUntil(this.destroyed);
    merge(this.resizeNotifier.resizeCanceled, this.resizeNotifier.triggerResize).pipe(takeUntilDestroyed, filter((columnSize) => columnSize.columnId === this.columnDef.name)).subscribe(({
      size,
      previousSize,
      completeImmediately
    }) => {
      this.elementRef.nativeElement.classList.add(OVERLAY_ACTIVE_CLASS);
      this._applySize(size, previousSize);
      if (completeImmediately) {
        this._completeResizeOperation();
      }
    });
    merge(this.resizeNotifier.resizeCanceled, this.resizeNotifier.resizeCompleted).pipe(takeUntilDestroyed).subscribe((columnSize) => {
      this._cleanUpAfterResize(columnSize);
    });
  }
  _completeResizeOperation() {
    this.ngZone.run(() => {
      this.resizeNotifier.resizeCompleted.next({
        columnId: this.columnDef.name,
        size: this.elementRef.nativeElement.offsetWidth
      });
    });
  }
  _cleanUpAfterResize(columnSize) {
    this.elementRef.nativeElement.classList.remove(OVERLAY_ACTIVE_CLASS);
    if (this.overlayRef && this.overlayRef.hasAttached()) {
      this._updateOverlayHandleHeight();
      this.overlayRef.updatePosition();
      if (columnSize.columnId === this.columnDef.name) {
        this.inlineHandle.focus();
      }
    }
  }
  _createHandlePortal() {
    const injector = Injector.create({
      parent: this.injector,
      providers: [{
        provide: ResizeRef,
        useValue: new ResizeRef(this.elementRef, this.overlayRef, this.minWidthPx, this.maxWidthPx)
      }]
    });
    return new ComponentPortal(this.getOverlayHandleComponentType(), this.viewContainerRef, injector);
  }
  _showHandleOverlay() {
    this._updateOverlayHandleHeight();
    this.overlayRef.attach(this._createHandlePortal());
    this.changeDetectorRef.markForCheck();
  }
  _updateOverlayHandleHeight() {
    this.overlayRef.updateSize({
      height: this.elementRef.nativeElement.offsetHeight
    });
  }
  _applySize(sizeInPixels, previousSize) {
    const sizeToApply = Math.min(Math.max(sizeInPixels, this.minWidthPx, 0), this.maxWidthPx);
    this.resizeStrategy.applyColumnSize(this.columnDef.cssClassFriendlyName, this.elementRef.nativeElement, sizeToApply, previousSize);
  }
  _applyMinWidthPx() {
    this.resizeStrategy.applyMinColumnSize(this.columnDef.cssClassFriendlyName, this.elementRef.nativeElement, this.minWidthPx);
  }
  _applyMaxWidthPx() {
    this.resizeStrategy.applyMaxColumnSize(this.columnDef.cssClassFriendlyName, this.elementRef.nativeElement, this.maxWidthPx);
  }
  _appendInlineHandle() {
    this.styleScheduler.schedule(() => {
      this.inlineHandle = this.document.createElement("div");
      this.inlineHandle.tabIndex = 0;
      this.inlineHandle.className = this.getInlineHandleCssClassName();
      this.elementRef.nativeElement.appendChild(this.inlineHandle);
    });
  }
};
_Resizable.ɵfac = function Resizable_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _Resizable)();
};
_Resizable.ɵdir = ɵɵdefineDirective({
  type: _Resizable
});
var Resizable = _Resizable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Resizable, [{
    type: Directive
  }], null, null);
})();
var _ResizeOverlayHandle = class _ResizeOverlayHandle {
  constructor() {
    this._renderer = inject(Renderer2);
    this.destroyed = new Subject();
    this._cumulativeDeltaX = 0;
  }
  ngAfterViewInit() {
    this._listenForMouseEvents();
  }
  ngOnDestroy() {
    this.destroyed.next();
    this.destroyed.complete();
  }
  _listenForMouseEvents() {
    this.ngZone.runOutsideAngular(() => {
      this._observableFromEvent(this.elementRef.nativeElement, "mouseenter").pipe(mapTo(this.resizeRef.origin.nativeElement), takeUntil(this.destroyed)).subscribe((cell) => this.eventDispatcher.headerCellHovered.next(cell));
      this._observableFromEvent(this.elementRef.nativeElement, "mouseleave").pipe(map((event) => event.relatedTarget && closest(event.relatedTarget, HEADER_CELL_SELECTOR)), takeUntil(this.destroyed)).subscribe((cell) => this.eventDispatcher.headerCellHovered.next(cell));
      this._observableFromEvent(this.elementRef.nativeElement, "mousedown").pipe(takeUntil(this.destroyed)).subscribe((mousedownEvent) => {
        this._dragStarted(mousedownEvent);
      });
    });
  }
  _dragStarted(mousedownEvent) {
    if (mousedownEvent.button !== 0) {
      return;
    }
    const mouseup = this._observableFromEvent(this.document, "mouseup");
    const mousemove = this._observableFromEvent(this.document, "mousemove");
    const escape = this._observableFromEvent(this.document, "keyup").pipe(filter((event) => event.keyCode === ESCAPE));
    const startX = mousedownEvent.screenX;
    const initialSize = this._getOriginWidth();
    let overlayOffset = 0;
    let originOffset = this._getOriginOffset();
    let size = initialSize;
    let overshot = 0;
    this._cumulativeDeltaX = 0;
    this.updateResizeActive(true);
    mouseup.pipe(takeUntil(merge(escape, this.destroyed))).subscribe(({
      screenX
    }) => {
      this.styleScheduler.scheduleEnd(() => {
        this._notifyResizeEnded(size, screenX !== startX);
      });
    });
    escape.pipe(takeUntil(merge(mouseup, this.destroyed))).subscribe(() => {
      this._notifyResizeEnded(initialSize);
    });
    mousemove.pipe(map(({
      screenX
    }) => screenX), startWith(startX), distinctUntilChanged(), pairwise(), takeUntil(merge(mouseup, escape, this.destroyed))).subscribe(([prevX, currX]) => {
      let deltaX = currX - prevX;
      if (!this.resizeRef.liveUpdates) {
        this._cumulativeDeltaX += deltaX;
        const sizeDelta = this._computeNewSize(size, this._cumulativeDeltaX) - size;
        this._updateOverlayOffset(sizeDelta);
        return;
      }
      if (overshot !== 0) {
        if (overshot < 0 && deltaX < 0 || overshot > 0 && deltaX > 0) {
          overshot += deltaX;
          return;
        } else {
          const remainingOvershot = overshot + deltaX;
          overshot = overshot > 0 ? Math.max(remainingOvershot, 0) : Math.min(remainingOvershot, 0);
          deltaX = remainingOvershot - overshot;
          if (deltaX === 0) {
            return;
          }
        }
      }
      this._triggerResize(size, deltaX);
      this.styleScheduler.scheduleEnd(() => {
        const originNewSize = this._getOriginWidth();
        const originNewOffset = this._getOriginOffset();
        const originOffsetDeltaX = originNewOffset - originOffset;
        const originSizeDeltaX = originNewSize - size;
        size = originNewSize;
        originOffset = originNewOffset;
        overshot += deltaX + (this._isLtr() ? -originSizeDeltaX : originSizeDeltaX);
        overlayOffset += originOffsetDeltaX + (this._isLtr() ? originSizeDeltaX : 0);
        this._updateOverlayOffset(overlayOffset);
      });
    });
  }
  updateResizeActive(active) {
    this.eventDispatcher.overlayHandleActiveForCell.next(active ? this.resizeRef.origin.nativeElement : null);
  }
  _triggerResize(startSize, deltaX) {
    this.resizeNotifier.triggerResize.next({
      columnId: this.columnDef.name,
      size: this._computeNewSize(startSize, deltaX),
      previousSize: startSize,
      isStickyColumn: this.columnDef.sticky || this.columnDef.stickyEnd
    });
  }
  _computeNewSize(startSize, deltaX) {
    let computedNewSize = startSize + (this._isLtr() ? deltaX : -deltaX);
    computedNewSize = Math.min(Math.max(computedNewSize, this.resizeRef.minWidthPx, 0), this.resizeRef.maxWidthPx);
    return computedNewSize;
  }
  _getOriginWidth() {
    return this.resizeRef.origin.nativeElement.offsetWidth;
  }
  _getOriginOffset() {
    return this.resizeRef.origin.nativeElement.offsetLeft;
  }
  _updateOverlayOffset(offset) {
    this.resizeRef.overlayRef.overlayElement.style.transform = `translateX(${coerceCssPixelValue(offset)})`;
  }
  _isLtr() {
    return this.directionality.value === "ltr";
  }
  _notifyResizeEnded(size, completedSuccessfully = false) {
    this.updateResizeActive(false);
    this.ngZone.run(() => {
      const sizeMessage = {
        columnId: this.columnDef.name,
        size: this._computeNewSize(size, this._cumulativeDeltaX)
      };
      if (completedSuccessfully) {
        if (!this.resizeRef.liveUpdates) {
          this._triggerResize(size, this._cumulativeDeltaX);
        }
        this.resizeNotifier.resizeCompleted.next(sizeMessage);
      } else {
        this.resizeNotifier.resizeCanceled.next(sizeMessage);
      }
    });
  }
  _observableFromEvent(element, name) {
    return new Observable((subscriber) => {
      const handler = (event) => subscriber.next(event);
      const cleanup = this._renderer.listen(element, name, handler);
      return () => {
        cleanup();
        subscriber.complete();
      };
    });
  }
};
_ResizeOverlayHandle.ɵfac = function ResizeOverlayHandle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ResizeOverlayHandle)();
};
_ResizeOverlayHandle.ɵdir = ɵɵdefineDirective({
  type: _ResizeOverlayHandle
});
var ResizeOverlayHandle = _ResizeOverlayHandle;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizeOverlayHandle, [{
    type: Directive
  }], null, null);
})();

// node_modules/@ng-matero/extensions/fesm2022/mtxGrid.mjs
var _c0 = ["top"];
var _c1 = (a0) => ({
  $implicit: a0
});
function MtxGridMenu_For_2_Conditional_0_Conditional_0_mat_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon");
  }
}
function MtxGridMenu_For_2_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵlistener("click", function MtxGridMenu_For_2_Conditional_0_Conditional_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const item_r2 = ɵɵnextContext(2).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(item_r2.click == null ? null : item_r2.click(ctx_r2.data));
    });
    ɵɵtemplate(2, MtxGridMenu_For_2_Conditional_0_Conditional_0_mat_icon_2_Template, 1, 0, "mat-icon", 5);
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()();
    ɵɵelement(5, "mtx-grid-menu", 6, 1);
  }
  if (rf & 2) {
    const gridMenu_r4 = ɵɵreference(6);
    const item_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext();
    const iconTpl_r5 = ɵɵreference(4);
    ɵɵclassMap(item_r2.class);
    ɵɵproperty("matMenuTriggerFor", gridMenu_r4.menu)("disabled", ɵɵpipeBind2(1, 9, item_r2, ctx_r2.data));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", iconTpl_r5)("ngTemplateOutletContext", ɵɵpureFunction1(12, _c1, item_r2));
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r2.text);
    ɵɵadvance();
    ɵɵproperty("items", item_r2.children)("data", ctx_r2.data);
  }
}
function MtxGridMenu_For_2_Conditional_0_Conditional_1_mat_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon");
  }
}
function MtxGridMenu_For_2_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵlistener("click", function MtxGridMenu_For_2_Conditional_0_Conditional_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const item_r2 = ɵɵnextContext(2).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(item_r2.click == null ? null : item_r2.click(ctx_r2.data));
    });
    ɵɵtemplate(2, MtxGridMenu_For_2_Conditional_0_Conditional_1_mat_icon_2_Template, 1, 0, "mat-icon", 5);
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext();
    const iconTpl_r5 = ɵɵreference(4);
    ɵɵclassMap(item_r2.class);
    ɵɵproperty("disabled", ɵɵpipeBind2(1, 6, item_r2, ctx_r2.data));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", iconTpl_r5)("ngTemplateOutletContext", ɵɵpureFunction1(9, _c1, item_r2));
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r2.text);
  }
}
function MtxGridMenu_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridMenu_For_2_Conditional_0_Conditional_0_Template, 7, 14)(1, MtxGridMenu_For_2_Conditional_0_Conditional_1_Template, 5, 11, "button", 3);
  }
  if (rf & 2) {
    const item_r2 = ɵɵnextContext().$implicit;
    ɵɵconditional(item_r2.children && item_r2.children.length > 0 ? 0 : 1);
  }
}
function MtxGridMenu_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridMenu_For_2_Conditional_0_Template, 2, 1);
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵconditional(!item_r2.iif || item_r2.iif(ctx_r2.data) ? 0 : -1);
  }
}
function MtxGridMenu_ng_template_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(item_r7.icon);
  }
}
function MtxGridMenu_ng_template_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon", 9);
  }
  if (rf & 2) {
    const item_r7 = ɵɵnextContext().$implicit;
    ɵɵproperty("fontIcon", item_r7.fontIcon);
  }
}
function MtxGridMenu_ng_template_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon", 10);
  }
  if (rf & 2) {
    const item_r7 = ɵɵnextContext().$implicit;
    ɵɵproperty("svgIcon", item_r7.svgIcon);
  }
}
function MtxGridMenu_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridMenu_ng_template_3_Conditional_0_Template, 2, 1, "mat-icon", 8)(1, MtxGridMenu_ng_template_3_Conditional_1_Template, 1, 1, "mat-icon", 9)(2, MtxGridMenu_ng_template_3_Conditional_2_Template, 1, 1, "mat-icon", 10);
  }
  if (rf & 2) {
    const item_r7 = ctx.$implicit;
    ɵɵconditional(item_r7.icon ? 0 : item_r7.fontIcon ? 1 : item_r7.svgIcon ? 2 : -1);
  }
}
var _c2 = () => [];
var _c3 = (a0, a1, a2, a3, a4) => [a0, a1, a2, a3, a4];
function MtxGridCell_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
    ɵɵpipe(1, "cellSummary");
    ɵɵpipe(2, "cellSummary");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("title", ctx_r0._getFormatterTooltip(ɵɵpipeBind2(1, 2, ctx_r0.data, ctx_r0.colDef)))("innerHTML", ctx_r0._getText(ɵɵpipeBind2(2, 5, ctx_r0.data, ctx_r0.colDef)), ɵɵsanitizeHtml);
  }
}
function MtxGridCell_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("title", ctx_r0._getFormatterTooltip(ctx_r0.colDef.formatter(ctx_r0.rowData, ctx_r0.colDef)))("innerHTML", ctx_r0._getText(ctx_r0.colDef.formatter(ctx_r0.rowData, ctx_r0.colDef)), ɵɵsanitizeHtml);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Conditional_0_mat_icon_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 6);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Conditional_0_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      return ɵɵresetView($event.stopPropagation());
    });
    ɵɵtemplate(24, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Conditional_0_mat_icon_24_Template, 1, 0, "mat-icon", 7);
    ɵɵelementEnd();
    ɵɵelement(25, "mtx-grid-menu", 8, 1);
  }
  if (rf & 2) {
    const gridMenu_r3 = ɵɵreference(26);
    const btn_r4 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    const iconTpl_r5 = ɵɵreference(3);
    ɵɵclassMap(btn_r4.class);
    ɵɵproperty("color", btn_r4.color || "primary")("disabled", ɵɵpipeBind4(1, 25, btn_r4, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 34, ɵɵpipeBind1(3, 32, ɵɵpipeBind1(2, 30, btn_r4).message)))("matTooltipClass", ɵɵpipeBind1(5, 36, btn_r4).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 38, btn_r4).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 40, btn_r4).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 42, btn_r4).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 44, btn_r4).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 46, btn_r4).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 48, btn_r4).disabled)("matBadge", ɵɵpipeBind1(14, 54, ɵɵpipeBind1(13, 52, ɵɵpipeBind1(12, 50, btn_r4).content)))("matBadgeDescription", ɵɵpipeBind1(17, 60, ɵɵpipeBind1(16, 58, ɵɵpipeBind1(15, 56, btn_r4).description)))("matBadgeColor", ɵɵpipeBind1(18, 62, btn_r4).color)("matBadgePosition", ɵɵpipeBind1(19, 64, btn_r4).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 66, btn_r4).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 68, btn_r4).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 70, btn_r4).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 72, btn_r4).hidden)("matMenuTriggerFor", btn_r4.children && btn_r4.children.length > 0 ? gridMenu_r3.menu : null);
    ɵɵadvance(24);
    ɵɵproperty("ngTemplateOutlet", iconTpl_r5)("ngTemplateOutletContext", ɵɵpureFunction1(74, _c1, btn_r4));
    ɵɵadvance();
    ɵɵproperty("items", btn_r4.children || ɵɵpureFunction0(76, _c2))("data", ctx_r0.rowData);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Conditional_1_mat_icon_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 9);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Conditional_1_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r6);
      return ɵɵresetView($event.stopPropagation());
    });
    ɵɵtemplate(24, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Conditional_1_mat_icon_24_Template, 1, 0, "mat-icon", 7);
    ɵɵelementStart(25, "span");
    ɵɵtext(26);
    ɵɵpipe(27, "toObservable");
    ɵɵpipe(28, "async");
    ɵɵelementEnd()();
    ɵɵelement(29, "mtx-grid-menu", 8, 1);
  }
  if (rf & 2) {
    const gridMenu_r7 = ɵɵreference(30);
    const btn_r4 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    const iconTpl_r5 = ɵɵreference(3);
    ɵɵclassMap(btn_r4.class);
    ɵɵproperty("matButton", btn_r4.type || "text")("color", btn_r4.color || "primary")("disabled", ɵɵpipeBind4(1, 27, btn_r4, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 36, ɵɵpipeBind1(3, 34, ɵɵpipeBind1(2, 32, btn_r4).message)))("matTooltipClass", ɵɵpipeBind1(5, 38, btn_r4).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 40, btn_r4).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 42, btn_r4).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 44, btn_r4).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 46, btn_r4).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 48, btn_r4).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 50, btn_r4).disabled)("matBadge", ɵɵpipeBind1(14, 56, ɵɵpipeBind1(13, 54, ɵɵpipeBind1(12, 52, btn_r4).content)))("matBadgeDescription", ɵɵpipeBind1(17, 62, ɵɵpipeBind1(16, 60, ɵɵpipeBind1(15, 58, btn_r4).description)))("matBadgeColor", ɵɵpipeBind1(18, 64, btn_r4).color)("matBadgePosition", ɵɵpipeBind1(19, 66, btn_r4).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 68, btn_r4).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 70, btn_r4).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 72, btn_r4).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 74, btn_r4).hidden)("matMenuTriggerFor", btn_r4.children && btn_r4.children.length > 0 ? gridMenu_r7.menu : null);
    ɵɵadvance(24);
    ɵɵproperty("ngTemplateOutlet", iconTpl_r5)("ngTemplateOutletContext", ɵɵpureFunction1(80, _c1, btn_r4));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(28, 78, ɵɵpipeBind1(27, 76, btn_r4.text)));
    ɵɵadvance(3);
    ɵɵproperty("items", btn_r4.children || ɵɵpureFunction0(82, _c2))("data", ctx_r0.rowData);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Conditional_0_Template, 27, 77)(1, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Conditional_1_Template, 31, 83);
  }
  if (rf & 2) {
    const btn_r4 = ɵɵnextContext(2).$implicit;
    ɵɵconditional(btn_r4.type === "icon" ? 0 : 1);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Conditional_0_mat_icon_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Conditional_0_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r8);
      const btn_r4 = ɵɵnextContext(3).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0._onActionClick($event, btn_r4, ctx_r0.rowData));
    });
    ɵɵtemplate(24, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Conditional_0_mat_icon_24_Template, 1, 0, "mat-icon", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const btn_r4 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    const iconTpl_r5 = ɵɵreference(3);
    ɵɵclassMap(btn_r4.class);
    ɵɵproperty("color", btn_r4.color || "primary")("disabled", ɵɵpipeBind4(1, 22, btn_r4, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 31, ɵɵpipeBind1(3, 29, ɵɵpipeBind1(2, 27, btn_r4).message)))("matTooltipClass", ɵɵpipeBind1(5, 33, btn_r4).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 35, btn_r4).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 37, btn_r4).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 39, btn_r4).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 41, btn_r4).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 43, btn_r4).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 45, btn_r4).disabled)("matBadge", ɵɵpipeBind1(14, 51, ɵɵpipeBind1(13, 49, ɵɵpipeBind1(12, 47, btn_r4).content)))("matBadgeDescription", ɵɵpipeBind1(17, 57, ɵɵpipeBind1(16, 55, ɵɵpipeBind1(15, 53, btn_r4).description)))("matBadgeColor", ɵɵpipeBind1(18, 59, btn_r4).color)("matBadgePosition", ɵɵpipeBind1(19, 61, btn_r4).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 63, btn_r4).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 65, btn_r4).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 67, btn_r4).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 69, btn_r4).hidden);
    ɵɵadvance(24);
    ɵɵproperty("ngTemplateOutlet", iconTpl_r5)("ngTemplateOutletContext", ɵɵpureFunction1(71, _c1, btn_r4));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Conditional_1_mat_icon_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13);
    ɵɵpipe(1, "cellActionDisable");
    ɵɵpipe(2, "cellActionTooltip");
    ɵɵpipe(3, "toObservable");
    ɵɵpipe(4, "async");
    ɵɵpipe(5, "cellActionTooltip");
    ɵɵpipe(6, "cellActionTooltip");
    ɵɵpipe(7, "cellActionTooltip");
    ɵɵpipe(8, "cellActionTooltip");
    ɵɵpipe(9, "cellActionTooltip");
    ɵɵpipe(10, "cellActionTooltip");
    ɵɵpipe(11, "cellActionTooltip");
    ɵɵpipe(12, "cellActionBadge");
    ɵɵpipe(13, "toObservable");
    ɵɵpipe(14, "async");
    ɵɵpipe(15, "cellActionBadge");
    ɵɵpipe(16, "toObservable");
    ɵɵpipe(17, "async");
    ɵɵpipe(18, "cellActionBadge");
    ɵɵpipe(19, "cellActionBadge");
    ɵɵpipe(20, "cellActionBadge");
    ɵɵpipe(21, "cellActionBadge");
    ɵɵpipe(22, "cellActionBadge");
    ɵɵpipe(23, "cellActionBadge");
    ɵɵlistener("click", function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Conditional_1_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r9);
      const btn_r4 = ɵɵnextContext(3).$implicit;
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r0._onActionClick($event, btn_r4, ctx_r0.rowData));
    });
    ɵɵtemplate(24, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Conditional_1_mat_icon_24_Template, 1, 0, "mat-icon", 7);
    ɵɵelementStart(25, "span");
    ɵɵtext(26);
    ɵɵpipe(27, "toObservable");
    ɵɵpipe(28, "async");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const btn_r4 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    const iconTpl_r5 = ɵɵreference(3);
    ɵɵclassMap(btn_r4.class);
    ɵɵproperty("matButton", btn_r4.type || "text")("color", btn_r4.color || "primary")("disabled", ɵɵpipeBind4(1, 24, btn_r4, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue))("matTooltip", ɵɵpipeBind1(4, 33, ɵɵpipeBind1(3, 31, ɵɵpipeBind1(2, 29, btn_r4).message)))("matTooltipClass", ɵɵpipeBind1(5, 35, btn_r4).class)("matTooltipHideDelay", ɵɵpipeBind1(6, 37, btn_r4).hideDelay)("matTooltipShowDelay", ɵɵpipeBind1(7, 39, btn_r4).showDelay)("matTooltipPosition", ɵɵpipeBind1(8, 41, btn_r4).position || "below")("matTooltipPositionAtOrigin", ɵɵpipeBind1(9, 43, btn_r4).positionAtOrigin)("matTooltipTouchGestures", ɵɵpipeBind1(10, 45, btn_r4).touchGestures || "auto")("matTooltipDisabled", ɵɵpipeBind1(11, 47, btn_r4).disabled)("matBadge", ɵɵpipeBind1(14, 53, ɵɵpipeBind1(13, 51, ɵɵpipeBind1(12, 49, btn_r4).content)))("matBadgeDescription", ɵɵpipeBind1(17, 59, ɵɵpipeBind1(16, 57, ɵɵpipeBind1(15, 55, btn_r4).description)))("matBadgeColor", ɵɵpipeBind1(18, 61, btn_r4).color)("matBadgePosition", ɵɵpipeBind1(19, 63, btn_r4).position || "above after")("matBadgeSize", ɵɵpipeBind1(20, 65, btn_r4).size || "medium")("matBadgeOverlap", ɵɵpipeBind1(21, 67, btn_r4).overlap)("matBadgeDisabled", ɵɵpipeBind1(22, 69, btn_r4).disabled)("matBadgeHidden", ɵɵpipeBind1(23, 71, btn_r4).hidden);
    ɵɵadvance(24);
    ɵɵproperty("ngTemplateOutlet", iconTpl_r5)("ngTemplateOutletContext", ɵɵpureFunction1(77, _c1, btn_r4));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(28, 75, ɵɵpipeBind1(27, 73, btn_r4.text)));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Conditional_0_Template, 25, 73, "button", 10)(1, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Conditional_1_Template, 29, 79, "button", 11);
  }
  if (rf & 2) {
    const btn_r4 = ɵɵnextContext(2).$implicit;
    ɵɵconditional(btn_r4.type === "icon" ? 0 : 1);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_0_Template, 2, 1)(1, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Conditional_1_Template, 2, 1);
  }
  if (rf & 2) {
    const btn_r4 = ɵɵnextContext().$implicit;
    ɵɵconditional(btn_r4.children && btn_r4.children.length > 0 ? 0 : 1);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Conditional_0_Template, 2, 1);
  }
  if (rf & 2) {
    const btn_r4 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵconditional(!btn_r4.iif || btn_r4.iif(ctx_r0.rowData) ? 0 : -1);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, MtxGridCell_Conditional_1_Conditional_1_Case_0_For_1_Template, 1, 1, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵpipe(2, "cellActions");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵrepeater(ɵɵpipeBind4(2, 0, ctx_r0.colDef.buttons, ctx_r0.rowData, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip-listbox")(1, "mat-chip", 14);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵclassMap("bg-" + ctx_r0.colDef.tag[ctx_r0._value].color);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.colDef.tag[ctx_r0._value].text, " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵtextInterpolate1(" ", ctx_r0._value, " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridCell_Conditional_1_Conditional_1_Case_1_Conditional_0_Template, 3, 3, "mat-chip-listbox")(1, MtxGridCell_Conditional_1_Conditional_1_Case_1_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵconditional(ctx_r0.colDef.tag && ctx_r0.colDef.tag[ctx_r0._value] ? 0 : 1);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("href", ctx_r0._value, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._value);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("src", ctx_r0._value, ɵɵsanitizeUrl);
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ctx_r0._value));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._getText(ctx_r0._value));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵpipe(1, "number");
    ɵɵtext(2);
    ɵɵpipe(3, "number");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ɵɵpipeBind3(1, 2, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0._getText(ɵɵpipeBind3(3, 6, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)), " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵpipe(1, "currency");
    ɵɵtext(2);
    ɵɵpipe(3, "currency");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ɵɵpipeBindV(1, 2, ɵɵpureFunction5(14, _c3, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.currencyCode, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.display, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale))));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0._getText(ɵɵpipeBindV(3, 8, ɵɵpureFunction5(20, _c3, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.currencyCode, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.display, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale))), " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵpipe(1, "percent");
    ɵɵtext(2);
    ɵɵpipe(3, "percent");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ɵɵpipeBind3(1, 2, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0._getText(ɵɵpipeBind3(3, 6, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.digitsInfo, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)), " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵpipe(1, "date");
    ɵɵtext(2);
    ɵɵpipe(3, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ɵɵpipeBind4(1, 2, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.format, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.timezone, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0._getText(ɵɵpipeBind4(3, 7, ctx_r0._value, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.format, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.timezone, ctx_r0.colDef.typeParameter == null ? null : ctx_r0.colDef.typeParameter.locale)), " ");
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Case_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("title", ctx_r0._getTooltip(ctx_r0._value));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._getText(ctx_r0._value));
  }
}
function MtxGridCell_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridCell_Conditional_1_Conditional_1_Case_0_Template, 3, 5)(1, MtxGridCell_Conditional_1_Conditional_1_Case_1_Template, 2, 1)(2, MtxGridCell_Conditional_1_Conditional_1_Case_2_Template, 2, 2, "a", 3)(3, MtxGridCell_Conditional_1_Conditional_1_Case_3_Template, 1, 1, "img", 4)(4, MtxGridCell_Conditional_1_Conditional_1_Case_4_Template, 2, 2, "span", 5)(5, MtxGridCell_Conditional_1_Conditional_1_Case_5_Template, 4, 10, "span", 5)(6, MtxGridCell_Conditional_1_Conditional_1_Case_6_Template, 4, 26, "span", 5)(7, MtxGridCell_Conditional_1_Conditional_1_Case_7_Template, 4, 10, "span", 5)(8, MtxGridCell_Conditional_1_Conditional_1_Case_8_Template, 4, 12, "span", 5)(9, MtxGridCell_Conditional_1_Conditional_1_Case_9_Template, 2, 2, "span", 5);
  }
  if (rf & 2) {
    let tmp_3_0;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional((tmp_3_0 = ctx_r0.colDef.type) === "button" ? 0 : tmp_3_0 === "tag" ? 1 : tmp_3_0 === "link" ? 2 : tmp_3_0 === "image" ? 3 : tmp_3_0 === "boolean" ? 4 : tmp_3_0 === "number" ? 5 : tmp_3_0 === "currency" ? 6 : tmp_3_0 === "percent" ? 7 : tmp_3_0 === "date" ? 8 : 9);
  }
}
function MtxGridCell_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridCell_Conditional_1_Conditional_0_Template, 1, 2, "span", 2)(1, MtxGridCell_Conditional_1_Conditional_1_Template, 10, 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(ctx_r0.colDef.formatter ? 0 : 1);
  }
}
function MtxGridCell_ng_template_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 15);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const btn_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(btn_r10.icon);
  }
}
function MtxGridCell_ng_template_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon", 16);
  }
  if (rf & 2) {
    const btn_r10 = ɵɵnextContext().$implicit;
    ɵɵproperty("fontIcon", btn_r10.fontIcon);
  }
}
function MtxGridCell_ng_template_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon", 17);
  }
  if (rf & 2) {
    const btn_r10 = ɵɵnextContext().$implicit;
    ɵɵproperty("svgIcon", btn_r10.svgIcon);
  }
}
function MtxGridCell_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridCell_ng_template_2_Conditional_0_Template, 2, 1, "mat-icon", 15)(1, MtxGridCell_ng_template_2_Conditional_1_Template, 1, 1, "mat-icon", 16)(2, MtxGridCell_ng_template_2_Conditional_2_Template, 1, 1, "mat-icon", 17);
  }
  if (rf & 2) {
    const btn_r10 = ctx.$implicit;
    ɵɵconditional(btn_r10.icon ? 0 : btn_r10.fontIcon ? 1 : btn_r10.svgIcon ? 2 : -1);
  }
}
var _forTrack0 = ($index, $item) => $item.field;
function MtxGridColumnMenu_Conditional_0_mat_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon");
  }
}
function MtxGridColumnMenu_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 13);
    ɵɵtemplate(1, MtxGridColumnMenu_Conditional_0_mat_icon_1_Template, 1, 0, "mat-icon", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const iconTpl_r3 = ɵɵreference(3);
    const menu_r4 = ɵɵreference(5);
    ɵɵclassMap(ctx_r1.buttonClass);
    ɵɵproperty("color", ctx_r1.buttonColor)("matMenuTriggerFor", menu_r4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", iconTpl_r3);
  }
}
function MtxGridColumnMenu_Conditional_1_mat_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon");
  }
}
function MtxGridColumnMenu_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 15);
    ɵɵtemplate(1, MtxGridColumnMenu_Conditional_1_mat_icon_1_Template, 1, 0, "mat-icon", 14);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const iconTpl_r3 = ɵɵreference(3);
    const menu_r4 = ɵɵreference(5);
    ɵɵclassMap(ctx_r1.buttonClass);
    ɵɵproperty("matButton", ctx_r1.buttonType)("color", ctx_r1.buttonColor)("matMenuTriggerFor", menu_r4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", iconTpl_r3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.buttonText, " ");
  }
}
function MtxGridColumnMenu_ng_template_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.buttonIcon);
  }
}
function MtxGridColumnMenu_ng_template_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon", 16);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("fontIcon", ctx_r1.buttonFontIcon);
  }
}
function MtxGridColumnMenu_ng_template_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-icon", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r1.buttonSvgIcon);
  }
}
function MtxGridColumnMenu_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridColumnMenu_ng_template_2_Conditional_0_Template, 2, 1, "mat-icon")(1, MtxGridColumnMenu_ng_template_2_Conditional_1_Template, 1, 1, "mat-icon", 16)(2, MtxGridColumnMenu_ng_template_2_Conditional_2_Template, 1, 1, "mat-icon", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(ctx_r1.buttonIcon ? 0 : ctx_r1.buttonFontIcon ? 1 : ctx_r1.buttonSvgIcon ? 2 : -1);
  }
}
function MtxGridColumnMenu_Conditional_7_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MtxGridColumnMenu_Conditional_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGridColumnMenu_Conditional_7_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 18);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.headerTemplate);
  }
}
function MtxGridColumnMenu_Conditional_7_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r1.headerText, " ");
  }
}
function MtxGridColumnMenu_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵconditionalCreate(1, MtxGridColumnMenu_Conditional_7_Conditional_1_Template, 1, 1, null, 18)(2, MtxGridColumnMenu_Conditional_7_Conditional_2_Template, 1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r1.headerTemplate ? 1 : 2);
  }
}
function MtxGridColumnMenu_Conditional_9_For_2_ng_template_3_Template(rf, ctx) {
}
function MtxGridColumnMenu_Conditional_9_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 21);
    ɵɵelement(2, "path", 22);
    ɵɵelementEnd();
    ɵɵtemplate(3, MtxGridColumnMenu_Conditional_9_For_2_ng_template_3_Template, 0, 0, "ng-template", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r6 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    const checkboxList_r7 = ɵɵreference(13);
    ɵɵproperty("cdkDragDisabled", ctx_r1.selectableChecked === "show" ? !col_r6.show : col_r6.hide);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", checkboxList_r7)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c1, col_r6));
  }
}
function MtxGridColumnMenu_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 19);
    ɵɵlistener("cdkDropListDropped", function MtxGridColumnMenu_Conditional_9_Template_div_cdkDropListDropped_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._handleDroped($event));
    });
    ɵɵrepeaterCreate(1, MtxGridColumnMenu_Conditional_9_For_2_Template, 4, 5, "div", 20, _forTrack0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.columns);
  }
}
function MtxGridColumnMenu_Conditional_10_For_2_ng_template_1_Template(rf, ctx) {
}
function MtxGridColumnMenu_Conditional_10_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 24);
    ɵɵtemplate(1, MtxGridColumnMenu_Conditional_10_For_2_ng_template_1_Template, 0, 0, "ng-template", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r8 = ctx.$implicit;
    ɵɵnextContext(2);
    const checkboxList_r7 = ɵɵreference(13);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", checkboxList_r7)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c1, col_r8));
  }
}
function MtxGridColumnMenu_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵrepeaterCreate(1, MtxGridColumnMenu_Conditional_10_For_2_Template, 2, 4, "div", 24, _forTrack0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.columns);
  }
}
function MtxGridColumnMenu_Conditional_11_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MtxGridColumnMenu_Conditional_11_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGridColumnMenu_Conditional_11_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 18);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.footerTemplate);
  }
}
function MtxGridColumnMenu_Conditional_11_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r1.footerText, " ");
  }
}
function MtxGridColumnMenu_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵconditionalCreate(1, MtxGridColumnMenu_Conditional_11_Conditional_1_Template, 1, 1, null, 18)(2, MtxGridColumnMenu_Conditional_11_Conditional_2_Template, 1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r1.footerTemplate ? 1 : 2);
  }
}
function MtxGridColumnMenu_ng_template_12_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 28);
    ɵɵelement(1, "path", 32);
    ɵɵelementEnd();
  }
}
function MtxGridColumnMenu_ng_template_12_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 29);
    ɵɵelement(1, "path", 33);
    ɵɵelementEnd();
  }
}
function MtxGridColumnMenu_ng_template_12_Conditional_0_For_6_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 36);
    ɵɵelement(1, "path", 38);
    ɵɵelementEnd();
  }
}
function MtxGridColumnMenu_ng_template_12_Conditional_0_For_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 34);
    ɵɵlistener("click", function MtxGridColumnMenu_ng_template_12_Conditional_0_For_6_Template_button_click_0_listener() {
      const item_r10 = ɵɵrestoreView(_r9).$implicit;
      const col_r11 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._handlePinSelect(col_r11, item_r10.value));
    });
    ɵɵelementStart(1, "span", 35);
    ɵɵconditionalCreate(2, MtxGridColumnMenu_ng_template_12_Conditional_0_For_6_Conditional_2_Template, 2, 0, ":svg:svg", 36);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 37);
    ɵɵtext(4);
    ɵɵpipe(5, "toObservable");
    ɵɵpipe(6, "async");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r10 = ctx.$implicit;
    const col_r11 = ɵɵnextContext(2).$implicit;
    ɵɵadvance(2);
    ɵɵconditional(col_r11.pinned == item_r10.value ? 2 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(6, 4, ɵɵpipeBind1(5, 2, item_r10.label)));
  }
}
function MtxGridColumnMenu_ng_template_12_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 27);
    ɵɵconditionalCreate(1, MtxGridColumnMenu_ng_template_12_Conditional_0_Conditional_1_Template, 2, 0, ":svg:svg", 28);
    ɵɵconditionalCreate(2, MtxGridColumnMenu_ng_template_12_Conditional_0_Conditional_2_Template, 2, 0, ":svg:svg", 29);
    ɵɵelementEnd();
    ɵɵelementStart(3, "mat-menu", 30, 3);
    ɵɵrepeaterCreate(5, MtxGridColumnMenu_ng_template_12_Conditional_0_For_6_Template, 7, 6, "button", 31, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const pinList_r12 = ɵɵreference(4);
    const col_r11 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("matMenuTriggerFor", pinList_r12);
    ɵɵadvance();
    ɵɵconditional(col_r11.pinned ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(!col_r11.pinned ? 2 : -1);
    ɵɵadvance(3);
    ɵɵrepeater(ctx_r1.pinOptions);
  }
}
function MtxGridColumnMenu_ng_template_12_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 39);
    ɵɵtwoWayListener("ngModelChange", function MtxGridColumnMenu_ng_template_12_Conditional_1_Template_mat_checkbox_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r13);
      const col_r11 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(col_r11[ctx_r1.selectableChecked], $event) || (col_r11[ctx_r1.selectableChecked] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("change", function MtxGridColumnMenu_ng_template_12_Conditional_1_Template_mat_checkbox_change_0_listener() {
      ɵɵrestoreView(_r13);
      const col_r11 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._handleChecked(col_r11));
    });
    ɵɵtext(1);
    ɵɵpipe(2, "toObservable");
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r11 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵtwoWayProperty("ngModel", col_r11[ctx_r1.selectableChecked]);
    ɵɵproperty("disabled", col_r11.disabled);
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind1(3, 5, ɵɵpipeBind1(2, 3, col_r11.header)));
  }
}
function MtxGridColumnMenu_ng_template_12_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 26);
    ɵɵtext(1);
    ɵɵpipe(2, "toObservable");
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r11 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind1(3, 3, ɵɵpipeBind1(2, 1, col_r11.header)));
  }
}
function MtxGridColumnMenu_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGridColumnMenu_ng_template_12_Conditional_0_Template, 7, 3);
    ɵɵconditionalCreate(1, MtxGridColumnMenu_ng_template_12_Conditional_1_Template, 4, 7, "mat-checkbox", 25)(2, MtxGridColumnMenu_ng_template_12_Conditional_2_Template, 4, 5, "span", 26);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(ctx_r1.pinnable ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.selectable ? 1 : 2);
  }
}
var _c4 = ["tableContainer"];
var _c5 = (a0, a1) => ({
  $implicit: a0,
  colDef: a1
});
var _c6 = (a0, a1, a2, a3) => ({
  $implicit: a0,
  rowData: a1,
  index: a2,
  colDef: a3
});
var _c7 = (a0, a1, a2) => ({
  $implicit: a0,
  colDef: a1,
  data: a2
});
var _c8 = (a0, a1, a2) => ({
  $implicit: a0,
  colData: a1,
  colDef: a2
});
var _c9 = () => ["MtxGridExpansionColumnDef"];
var _c10 = (a0, a1, a2, a3) => ({
  $implicit: a0,
  rowData: a1,
  index: a2,
  expanded: a3
});
function MtxGrid_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵelement(1, "mat-progress-bar", 16);
    ɵɵelementEnd();
  }
}
function MtxGrid_Conditional_1_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_1_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.toolbarTemplate);
  }
}
function MtxGrid_Conditional_1_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.toolbarTitle);
  }
}
function MtxGrid_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_Conditional_1_Conditional_3_Conditional_0_Template, 2, 1, "div", 20);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r0.toolbarTitle ? 0 : -1);
  }
}
function MtxGrid_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mtx-grid-column-menu", 21);
    ɵɵlistener("columnChange", function MtxGrid_Conditional_1_Conditional_5_Template_mtx_grid_column_menu_columnChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._onColumnChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("columns", ctx_r0.columns)("buttonText", ctx_r0.columnMenuButtonText)("buttonType", ctx_r0.columnMenuButtonType)("buttonColor", ctx_r0.columnMenuButtonColor)("buttonClass", ctx_r0.columnMenuButtonClass)("buttonIcon", ctx_r0.columnMenuButtonIcon)("buttonFontIcon", ctx_r0.columnMenuButtonFontIcon)("buttonSvgIcon", ctx_r0.columnMenuButtonSvgIcon)("selectable", ctx_r0.columnHideable)("selectableChecked", ctx_r0.columnHideableChecked)("sortable", ctx_r0.columnSortable)("pinnable", ctx_r0.columnPinnable)("showHeader", ctx_r0.showColumnMenuHeader)("headerText", ctx_r0.columnMenuHeaderText)("headerTemplate", ctx_r0.columnMenuHeaderTemplate)("showFooter", ctx_r0.showColumnMenuFooter)("footerText", ctx_r0.columnMenuFooterText)("footerTemplate", ctx_r0.columnMenuFooterTemplate)("pinOptions", ctx_r0.columnPinOptions);
  }
}
function MtxGrid_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3)(1, "div", 17);
    ɵɵconditionalCreate(2, MtxGrid_Conditional_1_Conditional_2_Template, 1, 1, null, 14)(3, MtxGrid_Conditional_1_Conditional_3_Template, 1, 1);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 18);
    ɵɵconditionalCreate(5, MtxGrid_Conditional_1_Conditional_5_Template, 1, 19, "mtx-grid-column-menu", 19);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵconditional(ctx_r0.toolbarTemplate ? 2 : 3);
    ɵɵadvance(3);
    ɵɵconditional(ctx_r0.showColumnMenuButton ? 5 : -1);
  }
}
function MtxGrid_Conditional_6_Conditional_1_th_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 33);
    ɵɵlistener("change", function MtxGrid_Conditional_6_Conditional_1_th_1_Conditional_1_Template_mat_checkbox_change_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView($event ? ctx_r0._toggleMasterCheckbox() : null);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("checked", ctx_r0.rowSelection.hasValue() && ctx_r0._isAllSelected())("indeterminate", ctx_r0.rowSelection.hasValue() && !ctx_r0._isAllSelected());
  }
}
function MtxGrid_Conditional_6_Conditional_1_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 31);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_6_Conditional_1_th_1_Conditional_1_Template, 1, 2, "mat-checkbox", 32);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.multiSelectable ? 1 : -1);
  }
}
function MtxGrid_Conditional_6_Conditional_1_td_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 36);
    ɵɵlistener("click", function MtxGrid_Conditional_6_Conditional_1_td_2_Conditional_1_Template_mat_checkbox_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      return ɵɵresetView($event.stopPropagation());
    })("change", function MtxGrid_Conditional_6_Conditional_1_td_2_Conditional_1_Template_mat_checkbox_change_0_listener($event) {
      ɵɵrestoreView(_r5);
      const row_r6 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView($event ? ctx_r0._toggleNormalCheckbox(row_r6) : null);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    const row_r6 = ctx_r6.$implicit;
    const index_r8 = ctx_r6.index;
    const dataIndex_r9 = ctx_r6.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("disabled", ctx_r0.rowSelectionFormatter.disabled && ctx_r0.rowSelectionFormatter.disabled(row_r6, ctx_r0._getIndex(index_r8, dataIndex_r9)))("checked", ctx_r0.rowSelection.isSelected(row_r6));
  }
}
function MtxGrid_Conditional_6_Conditional_1_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 34);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_6_Conditional_1_td_2_Conditional_1_Template, 1, 2, "mat-checkbox", 35);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r6 = ctx.$implicit;
    const index_r8 = ctx.index;
    const dataIndex_r9 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵconditional(!(ctx_r0.rowSelectionFormatter.hideCheckbox && ctx_r0.rowSelectionFormatter.hideCheckbox(row_r6, ctx_r0._getIndex(index_r8, dataIndex_r9))) ? 1 : -1);
  }
}
function MtxGrid_Conditional_6_Conditional_1_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 37);
  }
}
function MtxGrid_Conditional_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 23);
    ɵɵtemplate(1, MtxGrid_Conditional_6_Conditional_1_th_1_Template, 2, 1, "th", 28)(2, MtxGrid_Conditional_6_Conditional_1_td_2_Template, 2, 1, "td", 29)(3, MtxGrid_Conditional_6_Conditional_1_td_3_Template, 1, 0, "td", 30);
    ɵɵelementContainerEnd();
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_th_1_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c5, col_r10, col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplate[col_r10.field])("ngTemplateOutletContext", ɵɵpureFunction2(2, _c5, col_r10, col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 45);
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 46);
    ɵɵelement(1, "path", 47);
    ɵɵelementEnd();
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_ng_template_7_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 44);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Conditional_1_Template, 1, 0, "span", 45);
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵpipe(4, "toObservable");
    ɵɵpipe(5, "async");
    ɵɵelementEnd();
    ɵɵconditionalCreate(6, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Conditional_6_Template, 2, 0, ":svg:svg", 46);
    ɵɵelementEnd();
    ɵɵtemplate(7, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_ng_template_7_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    const headerExtraTplBase_r11 = ɵɵreference(16);
    ɵɵproperty("mat-sort-header", (col_r10.sortProp == null ? null : col_r10.sortProp.id) || col_r10.field)("disabled", !col_r10.sortable)("disableClear", (col_r10.sortProp == null ? null : col_r10.sortProp.disableClear) ?? ctx_r0.sortDisableClear)("arrowPosition", col_r10.sortProp == null ? null : col_r10.sortProp.arrowPosition)("start", col_r10.sortProp == null ? null : col_r10.sortProp.start);
    ɵɵadvance();
    ɵɵconditional(col_r10.showExpand ? 1 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(5, 12, ɵɵpipeBind1(4, 10, col_r10.header)));
    ɵɵadvance(3);
    ɵɵconditional(col_r10.sortable ? 6 : -1);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", headerExtraTplBase_r11)("ngTemplateOutletContext", ɵɵpureFunction2(14, _c5, ctx_r0.headerExtraTemplate, col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_0_Template, 1, 5, null, 43);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵconditionalBranchCreate(2, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Conditional_2_Template, 8, 17);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.headerTemplate == null ? null : ctx_r0.headerTemplate[col_r10.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_6_For_3_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 41);
    ɵɵpipe(1, "colClass");
    ɵɵelementStart(2, "div", 42);
    ɵɵconditionalCreate(3, MtxGrid_Conditional_6_For_3_th_1_Conditional_3_Template, 1, 5, null, 43);
    ɵɵpipe(4, "isTemplateRef");
    ɵɵconditionalBranchCreate(5, MtxGrid_Conditional_6_For_3_th_1_Conditional_5_Template, 3, 3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap(ɵɵpipeBind1(1, 15, col_r10));
    ɵɵstyleProp("width", col_r10.width)("min-width", col_r10.width)("left", col_r10.left)("right", col_r10.right);
    ɵɵclassProp("mat-table-sticky-left", col_r10.pinned === "left")("mat-table-sticky-right", col_r10.pinned === "right");
    ɵɵadvance(3);
    ɵɵconditional(ɵɵpipeBind1(4, 17, ctx_r0.headerTemplate) ? 3 : 5);
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const ctx_r13 = ɵɵnextContext();
    const row_r13 = ctx_r13.$implicit;
    const index_r15 = ctx_r13.index;
    const dataIndex_r16 = ctx_r13.dataIndex;
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.cellTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c6, row_r13, row_r13, ctx_r0._getIndex(index_r15, dataIndex_r16), col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const ctx_r13 = ɵɵnextContext(2);
    const row_r13 = ctx_r13.$implicit;
    const index_r15 = ctx_r13.index;
    const dataIndex_r16 = ctx_r13.dataIndex;
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.cellTemplate[col_r10.field])("ngTemplateOutletContext", ɵɵpureFunction4(2, _c6, row_r13, row_r13, ctx_r0._getIndex(index_r15, dataIndex_r16), col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const ctx_r13 = ɵɵnextContext(3);
    const row_r13 = ctx_r13.$implicit;
    const index_r15 = ctx_r13.index;
    const dataIndex_r16 = ctx_r13.dataIndex;
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", col_r10.cellTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c6, row_r13, row_r13, ctx_r0._getIndex(index_r15, dataIndex_r16), col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 51);
    ɵɵtwoWayListener("openedChange", function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template_button_openedChange_0_listener($event) {
      ɵɵrestoreView(_r18);
      const dataIndex_r16 = ɵɵnextContext(4).dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      ɵɵtwoWayBindingSet(ctx_r0.expansionRowStates[dataIndex_r16].expanded, $event) || (ctx_r0.expansionRowStates[dataIndex_r16].expanded = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("toggleChange", function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template_button_toggleChange_0_listener($event) {
      ɵɵrestoreView(_r18);
      const ctx_r13 = ɵɵnextContext(4);
      const row_r13 = ctx_r13.$implicit;
      const dataIndex_r16 = ctx_r13.dataIndex;
      const col_r10 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._onExpansionChange($event, row_r13, col_r10, dataIndex_r16));
    });
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 52);
    ɵɵelement(2, "path", 53);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const dataIndex_r16 = ɵɵnextContext(4).dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵtwoWayProperty("opened", ctx_r0.expansionRowStates[dataIndex_r16].expanded);
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵconditionalCreate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template, 3, 1, "button", 49);
    ɵɵelementStart(1, "mtx-grid-cell", 50);
    ɵɵlistener("rowDataChange", function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template_mtx_grid_cell_rowDataChange_1_listener($event) {
      ɵɵrestoreView(_r17);
      const ctx_r0 = ɵɵnextContext(6);
      return ɵɵresetView(ctx_r0._onRowDataChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r13 = ɵɵnextContext(3).$implicit;
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(col_r10.showExpand ? 0 : -1);
    ɵɵadvance();
    ɵɵproperty("rowData", row_r13)("colDef", col_r10)("placeholder", ctx_r0.emptyValuePlaceholder);
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_Template, 1, 7, null, 43)(1, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template, 2, 4);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(3).$implicit;
    ɵɵconditional(col_r10.cellTemplate ? 0 : 1);
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_0_Template, 1, 7, null, 43);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵconditionalBranchCreate(2, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Conditional_2_Template, 2, 1);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.cellTemplate == null ? null : ctx_r0.cellTemplate[col_r10.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_6_For_3_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 48);
    ɵɵpipe(1, "colClass");
    ɵɵlistener("cellSelectedChange", function MtxGrid_Conditional_6_For_3_td_2_Template_td_cellSelectedChange_0_listener($event) {
      const row_r13 = ɵɵrestoreView(_r12).$implicit;
      const col_r10 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._selectCell($event, row_r13, col_r10));
    });
    ɵɵconditionalCreate(2, MtxGrid_Conditional_6_For_3_td_2_Conditional_2_Template, 1, 7, null, 43);
    ɵɵpipe(3, "isTemplateRef");
    ɵɵconditionalBranchCreate(4, MtxGrid_Conditional_6_For_3_td_2_Conditional_4_Template, 3, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r13 = ctx.$implicit;
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap(ɵɵpipeBind4(1, 16, col_r10, row_r13, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue));
    ɵɵstyleProp("width", col_r10.width)("min-width", col_r10.width)("left", col_r10.left)("right", col_r10.right);
    ɵɵclassProp("mat-table-sticky-left", col_r10.pinned === "left")("mat-table-sticky-right", col_r10.pinned === "right");
    ɵɵproperty("cellSelectable", ctx_r0.cellSelectable);
    ɵɵadvance(2);
    ɵɵconditional(ɵɵpipeBind1(3, 21, ctx_r0.cellTemplate) ? 2 : 4);
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 45);
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_3_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.summaryTemplate)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c7, col_r10, col_r10, ctx_r0.data));
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.summaryTemplate[col_r10.field])("ngTemplateOutletContext", ɵɵpureFunction3(2, _c8, ctx_r0._getColData(ctx_r0.data, col_r10), ctx_r0._getColData(ctx_r0.data, col_r10), col_r10));
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mtx-grid-cell", 55);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("summary", true)("data", ctx_r0.data)("colDef", col_r10)("placeholder", ctx_r0.emptyValuePlaceholder);
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_0_Template, 1, 6, null, 43);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵconditionalBranchCreate(2, MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Conditional_2_Template, 1, 4, "mtx-grid-cell", 55);
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.summaryTemplate == null ? null : ctx_r0.summaryTemplate[col_r10.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_6_For_3_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 54);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_6_For_3_td_3_Conditional_1_Template, 1, 0, "span", 45);
    ɵɵconditionalCreate(2, MtxGrid_Conditional_6_For_3_td_3_Conditional_2_Template, 1, 6, null, 43);
    ɵɵpipe(3, "isTemplateRef");
    ɵɵconditionalBranchCreate(4, MtxGrid_Conditional_6_For_3_td_3_Conditional_4_Template, 3, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r10 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleProp("width", col_r10.width)("min-width", col_r10.width)("left", col_r10.left)("right", col_r10.right);
    ɵɵclassProp("mat-table-sticky-left", col_r10.pinned === "left")("mat-table-sticky-right", col_r10.pinned === "right");
    ɵɵadvance();
    ɵɵconditional(col_r10.showExpand ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ɵɵpipeBind1(3, 14, ctx_r0.summaryTemplate) ? 2 : 4);
  }
}
function MtxGrid_Conditional_6_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 24);
    ɵɵtemplate(1, MtxGrid_Conditional_6_For_3_th_1_Template, 6, 19, "th", 38)(2, MtxGrid_Conditional_6_For_3_td_2_Template, 5, 23, "td", 39)(3, MtxGrid_Conditional_6_For_3_td_3_Template, 5, 16, "td", 40);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const col_r10 = ctx.$implicit;
    ɵɵproperty("matColumnDef", col_r10.field)("sticky", col_r10.pinned === "left")("stickyEnd", col_r10.pinned === "right");
  }
}
function MtxGrid_Conditional_6_Conditional_4_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 25);
  }
}
function MtxGrid_Conditional_6_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_Conditional_4_tr_0_Template, 1, 0, "tr", 56);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matHeaderRowDef", ctx_r0.displayedColumns)("matHeaderRowDefSticky", true);
  }
}
function MtxGrid_Conditional_6_Conditional_5_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r19 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr", 58);
    ɵɵpipe(1, "rowClass");
    ɵɵlistener("click", function MtxGrid_Conditional_6_Conditional_5_tr_0_Template_tr_click_0_listener($event) {
      const ctx_r19 = ɵɵrestoreView(_r19);
      const row_r21 = ctx_r19.$implicit;
      const index_r22 = ctx_r19.index;
      const dataIndex_r23 = ctx_r19.dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0._selectRow($event, row_r21, ctx_r0._getIndex(index_r22, dataIndex_r23)));
    })("contextmenu", function MtxGrid_Conditional_6_Conditional_5_tr_0_Template_tr_contextmenu_0_listener($event) {
      const ctx_r23 = ɵɵrestoreView(_r19);
      const row_r21 = ctx_r23.$implicit;
      const index_r22 = ctx_r23.index;
      const dataIndex_r23 = ctx_r23.dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0._contextmenu($event, row_r21, ctx_r0._getIndex(index_r22, dataIndex_r23)));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r21 = ctx.$implicit;
    const index_r22 = ctx.index;
    const dataIndex_r23 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassMap(ɵɵpipeBind4(1, 4, row_r21, index_r22, dataIndex_r23, ctx_r0.rowClassFormatter));
    ɵɵclassProp("selected", ctx_r0.rowSelection.isSelected(row_r21));
  }
}
function MtxGrid_Conditional_6_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_Conditional_5_tr_0_Template, 2, 9, "tr", 57);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matRowDefColumns", ctx_r0.displayedColumns);
  }
}
function MtxGrid_Conditional_6_Conditional_6_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 27);
  }
}
function MtxGrid_Conditional_6_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_6_Conditional_6_tr_0_Template, 1, 0, "tr", 59);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matFooterRowDef", ctx_r0.displayedColumns)("matFooterRowDefSticky", true);
  }
}
function MtxGrid_Conditional_6_Conditional_7_td_1_ng_template_3_Template(rf, ctx) {
}
function MtxGrid_Conditional_6_Conditional_7_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 63)(1, "div", 64)(2, "div", 65);
    ɵɵtemplate(3, MtxGrid_Conditional_6_Conditional_7_td_1_ng_template_3_Template, 0, 0, "ng-template", 43);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const row_r25 = ctx.$implicit;
    const dataIndex_r26 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵattribute("colspan", ctx_r0.displayedColumns.length);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.expansionTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(3, _c10, row_r25, row_r25, dataIndex_r26, ctx_r0.expansionRowStates[dataIndex_r26].expanded));
  }
}
function MtxGrid_Conditional_6_Conditional_7_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 66);
  }
  if (rf & 2) {
    const dataIndex_r27 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassMap(ctx_r0.expansionRowStates[dataIndex_r27].expanded ? "expanded" : "collapsed");
  }
}
function MtxGrid_Conditional_6_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 60);
    ɵɵtemplate(1, MtxGrid_Conditional_6_Conditional_7_td_1_Template, 4, 8, "td", 61);
    ɵɵelementContainerEnd();
    ɵɵtemplate(2, MtxGrid_Conditional_6_Conditional_7_tr_2_Template, 1, 2, "tr", 62);
  }
  if (rf & 2) {
    ɵɵadvance(2);
    ɵɵproperty("matRowDefColumns", ɵɵpureFunction0(1, _c9));
  }
}
function MtxGrid_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "table", 22);
    ɵɵlistener("matSortChange", function MtxGrid_Conditional_6_Template_table_matSortChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0._onSortChange($event));
    });
    ɵɵconditionalCreate(1, MtxGrid_Conditional_6_Conditional_1_Template, 4, 0, "ng-container", 23);
    ɵɵrepeaterCreate(2, MtxGrid_Conditional_6_For_3_Template, 4, 3, "ng-container", 24, _forTrack0);
    ɵɵconditionalCreate(4, MtxGrid_Conditional_6_Conditional_4_Template, 1, 2, "tr", 25);
    ɵɵconditionalCreate(5, MtxGrid_Conditional_6_Conditional_5_Template, 1, 1, "tr", 26);
    ɵɵconditionalCreate(6, MtxGrid_Conditional_6_Conditional_6_Template, 1, 2, "tr", 27);
    ɵɵconditionalCreate(7, MtxGrid_Conditional_6_Conditional_7_Template, 3, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("mat-table-hover", ctx_r0.rowHover)("mat-table-striped", ctx_r0.rowStriped)("mat-table-expandable", ctx_r0.expandable);
    ɵɵproperty("dataSource", ctx_r0.dataSource)("multiTemplateDataRows", ctx_r0.expandable)("matSortActive", ctx_r0.sortActive)("matSortDirection", ctx_r0.sortDirection)("matSortDisableClear", ctx_r0.sortDisableClear)("matSortDisabled", ctx_r0.sortDisabled)("matSortStart", ctx_r0.sortStart)("trackBy", ctx_r0.trackBy);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.rowSelectable && !ctx_r0.hideRowSelectionCheckbox ? 1 : -1);
    ɵɵadvance();
    ɵɵrepeater(ctx_r0.columns);
    ɵɵadvance(2);
    ɵɵconditional(!ctx_r0.useContentHeaderRowTemplate ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.useContentRowTemplate ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0._whetherShowSummary ? 6 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.expandable ? 7 : -1);
  }
}
function MtxGrid_Conditional_7_Conditional_1_th_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 33);
    ɵɵlistener("change", function MtxGrid_Conditional_7_Conditional_1_th_1_Conditional_1_Template_mat_checkbox_change_0_listener($event) {
      ɵɵrestoreView(_r29);
      const ctx_r0 = ɵɵnextContext(4);
      return ɵɵresetView($event ? ctx_r0._toggleMasterCheckbox() : null);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("checked", ctx_r0.rowSelection.hasValue() && ctx_r0._isAllSelected())("indeterminate", ctx_r0.rowSelection.hasValue() && !ctx_r0._isAllSelected());
  }
}
function MtxGrid_Conditional_7_Conditional_1_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 31);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_7_Conditional_1_th_1_Conditional_1_Template, 1, 2, "mat-checkbox", 32);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.multiSelectable ? 1 : -1);
  }
}
function MtxGrid_Conditional_7_Conditional_1_td_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r30 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 36);
    ɵɵlistener("click", function MtxGrid_Conditional_7_Conditional_1_td_2_Conditional_1_Template_mat_checkbox_click_0_listener($event) {
      ɵɵrestoreView(_r30);
      return ɵɵresetView($event.stopPropagation());
    })("change", function MtxGrid_Conditional_7_Conditional_1_td_2_Conditional_1_Template_mat_checkbox_change_0_listener($event) {
      ɵɵrestoreView(_r30);
      const row_r31 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView($event ? ctx_r0._toggleNormalCheckbox(row_r31) : null);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r31 = ɵɵnextContext();
    const row_r31 = ctx_r31.$implicit;
    const index_r33 = ctx_r31.index;
    const dataIndex_r34 = ctx_r31.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("disabled", ctx_r0.rowSelectionFormatter.disabled && ctx_r0.rowSelectionFormatter.disabled(row_r31, ctx_r0._getIndex(index_r33, dataIndex_r34)))("checked", ctx_r0.rowSelection.isSelected(row_r31));
  }
}
function MtxGrid_Conditional_7_Conditional_1_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 34);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_7_Conditional_1_td_2_Conditional_1_Template, 1, 2, "mat-checkbox", 35);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r31 = ctx.$implicit;
    const index_r33 = ctx.index;
    const dataIndex_r34 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵconditional(!(ctx_r0.rowSelectionFormatter.hideCheckbox && ctx_r0.rowSelectionFormatter.hideCheckbox(row_r31, ctx_r0._getIndex(index_r33, dataIndex_r34))) ? 1 : -1);
  }
}
function MtxGrid_Conditional_7_Conditional_1_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 37);
  }
}
function MtxGrid_Conditional_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 23);
    ɵɵtemplate(1, MtxGrid_Conditional_7_Conditional_1_th_1_Template, 2, 1, "th", 28)(2, MtxGrid_Conditional_7_Conditional_1_td_2_Template, 2, 1, "td", 29)(3, MtxGrid_Conditional_7_Conditional_1_td_3_Template, 1, 0, "td", 30);
    ɵɵelementContainerEnd();
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_th_1_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c5, col_r35, col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplate[col_r35.field])("ngTemplateOutletContext", ɵɵpureFunction2(2, _c5, col_r35, col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 45);
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 46);
    ɵɵelement(1, "path", 47);
    ɵɵelementEnd();
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_ng_template_7_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 44);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Conditional_1_Template, 1, 0, "span", 45);
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵpipe(4, "toObservable");
    ɵɵpipe(5, "async");
    ɵɵelementEnd();
    ɵɵconditionalCreate(6, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Conditional_6_Template, 2, 0, ":svg:svg", 46);
    ɵɵelementEnd();
    ɵɵtemplate(7, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_ng_template_7_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    const headerExtraTplBase_r11 = ɵɵreference(16);
    ɵɵproperty("mat-sort-header", (col_r35.sortProp == null ? null : col_r35.sortProp.id) || col_r35.field)("disabled", !col_r35.sortable)("disableClear", (col_r35.sortProp == null ? null : col_r35.sortProp.disableClear) ?? ctx_r0.sortDisableClear)("arrowPosition", col_r35.sortProp == null ? null : col_r35.sortProp.arrowPosition)("start", col_r35.sortProp == null ? null : col_r35.sortProp.start);
    ɵɵadvance();
    ɵɵconditional(col_r35.showExpand ? 1 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(5, 12, ɵɵpipeBind1(4, 10, col_r35.header)));
    ɵɵadvance(3);
    ɵɵconditional(col_r35.sortable ? 6 : -1);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", headerExtraTplBase_r11)("ngTemplateOutletContext", ɵɵpureFunction2(14, _c5, ctx_r0.headerExtraTemplate, col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_0_Template, 1, 5, null, 43);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵconditionalBranchCreate(2, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Conditional_2_Template, 8, 17);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.headerTemplate == null ? null : ctx_r0.headerTemplate[col_r35.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_7_For_3_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 71);
    ɵɵpipe(1, "colClass");
    ɵɵelementStart(2, "div", 42);
    ɵɵconditionalCreate(3, MtxGrid_Conditional_7_For_3_th_1_Conditional_3_Template, 1, 5, null, 43);
    ɵɵpipe(4, "isTemplateRef");
    ɵɵconditionalBranchCreate(5, MtxGrid_Conditional_7_For_3_th_1_Conditional_5_Template, 3, 3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap(ɵɵpipeBind1(1, 16, col_r35));
    ɵɵstyleProp("width", col_r35.width)("left", col_r35.left)("right", col_r35.right);
    ɵɵclassProp("mat-table-sticky-left", col_r35.pinned === "left")("mat-table-sticky-right", col_r35.pinned === "right");
    ɵɵproperty("resizable", col_r35.resizable)("matResizableMinWidthPx", col_r35.minWidth)("matResizableMaxWidthPx", col_r35.maxWidth);
    ɵɵadvance(3);
    ɵɵconditional(ɵɵpipeBind1(4, 18, ctx_r0.headerTemplate) ? 3 : 5);
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const ctx_r37 = ɵɵnextContext();
    const row_r37 = ctx_r37.$implicit;
    const index_r39 = ctx_r37.index;
    const dataIndex_r40 = ctx_r37.dataIndex;
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.cellTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c6, row_r37, row_r37, ctx_r0._getIndex(index_r39, dataIndex_r40), col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const ctx_r37 = ɵɵnextContext(2);
    const row_r37 = ctx_r37.$implicit;
    const index_r39 = ctx_r37.index;
    const dataIndex_r40 = ctx_r37.dataIndex;
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.cellTemplate[col_r35.field])("ngTemplateOutletContext", ɵɵpureFunction4(2, _c6, row_r37, row_r37, ctx_r0._getIndex(index_r39, dataIndex_r40), col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const ctx_r37 = ɵɵnextContext(3);
    const row_r37 = ctx_r37.$implicit;
    const index_r39 = ctx_r37.index;
    const dataIndex_r40 = ctx_r37.dataIndex;
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", col_r35.cellTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c6, row_r37, row_r37, ctx_r0._getIndex(index_r39, dataIndex_r40), col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r42 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 51);
    ɵɵtwoWayListener("openedChange", function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template_button_openedChange_0_listener($event) {
      ɵɵrestoreView(_r42);
      const dataIndex_r40 = ɵɵnextContext(4).dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      ɵɵtwoWayBindingSet(ctx_r0.expansionRowStates[dataIndex_r40].expanded, $event) || (ctx_r0.expansionRowStates[dataIndex_r40].expanded = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("toggleChange", function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template_button_toggleChange_0_listener($event) {
      ɵɵrestoreView(_r42);
      const ctx_r37 = ɵɵnextContext(4);
      const row_r37 = ctx_r37.$implicit;
      const dataIndex_r40 = ctx_r37.dataIndex;
      const col_r35 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._onExpansionChange($event, row_r37, col_r35, dataIndex_r40));
    });
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 52);
    ɵɵelement(2, "path", 53);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const dataIndex_r40 = ɵɵnextContext(4).dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵtwoWayProperty("opened", ctx_r0.expansionRowStates[dataIndex_r40].expanded);
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r41 = ɵɵgetCurrentView();
    ɵɵconditionalCreate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Conditional_0_Template, 3, 1, "button", 49);
    ɵɵelementStart(1, "mtx-grid-cell", 50);
    ɵɵlistener("rowDataChange", function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template_mtx_grid_cell_rowDataChange_1_listener($event) {
      ɵɵrestoreView(_r41);
      const ctx_r0 = ɵɵnextContext(6);
      return ɵɵresetView(ctx_r0._onRowDataChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r37 = ɵɵnextContext(3).$implicit;
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(col_r35.showExpand ? 0 : -1);
    ɵɵadvance();
    ɵɵproperty("rowData", row_r37)("colDef", col_r35)("placeholder", ctx_r0.emptyValuePlaceholder);
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_0_Template, 1, 7, null, 43)(1, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Conditional_1_Template, 2, 4);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(3).$implicit;
    ɵɵconditional(col_r35.cellTemplate ? 0 : 1);
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_0_Template, 1, 7, null, 43);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵconditionalBranchCreate(2, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Conditional_2_Template, 2, 1);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.cellTemplate == null ? null : ctx_r0.cellTemplate[col_r35.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_7_For_3_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r36 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 48);
    ɵɵpipe(1, "colClass");
    ɵɵlistener("cellSelectedChange", function MtxGrid_Conditional_7_For_3_td_2_Template_td_cellSelectedChange_0_listener($event) {
      const row_r37 = ɵɵrestoreView(_r36).$implicit;
      const col_r35 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._selectCell($event, row_r37, col_r35));
    });
    ɵɵconditionalCreate(2, MtxGrid_Conditional_7_For_3_td_2_Conditional_2_Template, 1, 7, null, 43);
    ɵɵpipe(3, "isTemplateRef");
    ɵɵconditionalBranchCreate(4, MtxGrid_Conditional_7_For_3_td_2_Conditional_4_Template, 3, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r37 = ctx.$implicit;
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap(ɵɵpipeBind4(1, 14, col_r35, row_r37, ctx_r0.rowChangeRecord, ctx_r0.rowChangeRecord == null ? null : ctx_r0.rowChangeRecord.currentValue));
    ɵɵstyleProp("width", col_r35.width)("left", col_r35.left)("right", col_r35.right);
    ɵɵclassProp("mat-table-sticky-left", col_r35.pinned === "left")("mat-table-sticky-right", col_r35.pinned === "right");
    ɵɵproperty("cellSelectable", ctx_r0.cellSelectable);
    ɵɵadvance(2);
    ɵɵconditional(ɵɵpipeBind1(3, 19, ctx_r0.cellTemplate) ? 2 : 4);
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 45);
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_3_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.summaryTemplate)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c7, col_r35, col_r35, ctx_r0.data));
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.summaryTemplate[col_r35.field])("ngTemplateOutletContext", ɵɵpureFunction3(2, _c8, ctx_r0._getColData(ctx_r0.data, col_r35), ctx_r0._getColData(ctx_r0.data, col_r35), col_r35));
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mtx-grid-cell", 55);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("summary", true)("data", ctx_r0.data)("colDef", col_r35)("placeholder", ctx_r0.emptyValuePlaceholder);
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_0_Template, 1, 6, null, 43);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵconditionalBranchCreate(2, MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Conditional_2_Template, 1, 4, "mtx-grid-cell", 55);
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(ɵɵpipeBind1(1, 1, ctx_r0.summaryTemplate == null ? null : ctx_r0.summaryTemplate[col_r35.field]) ? 0 : 2);
  }
}
function MtxGrid_Conditional_7_For_3_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 54);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_7_For_3_td_3_Conditional_1_Template, 1, 0, "span", 45);
    ɵɵconditionalCreate(2, MtxGrid_Conditional_7_For_3_td_3_Conditional_2_Template, 1, 6, null, 43);
    ɵɵpipe(3, "isTemplateRef");
    ɵɵconditionalBranchCreate(4, MtxGrid_Conditional_7_For_3_td_3_Conditional_4_Template, 3, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const col_r35 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleProp("width", col_r35.width)("left", col_r35.left)("right", col_r35.right);
    ɵɵclassProp("mat-table-sticky-left", col_r35.pinned === "left")("mat-table-sticky-right", col_r35.pinned === "right");
    ɵɵadvance();
    ɵɵconditional(col_r35.showExpand ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(ɵɵpipeBind1(3, 12, ctx_r0.summaryTemplate) ? 2 : 4);
  }
}
function MtxGrid_Conditional_7_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 24);
    ɵɵtemplate(1, MtxGrid_Conditional_7_For_3_th_1_Template, 6, 20, "th", 68)(2, MtxGrid_Conditional_7_For_3_td_2_Template, 5, 21, "td", 69)(3, MtxGrid_Conditional_7_For_3_td_3_Template, 5, 14, "td", 70);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const col_r35 = ctx.$implicit;
    ɵɵproperty("matColumnDef", col_r35.field)("sticky", col_r35.pinned === "left")("stickyEnd", col_r35.pinned === "right");
  }
}
function MtxGrid_Conditional_7_Conditional_4_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 25);
  }
}
function MtxGrid_Conditional_7_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_Conditional_4_tr_0_Template, 1, 0, "tr", 56);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matHeaderRowDef", ctx_r0.displayedColumns)("matHeaderRowDefSticky", true);
  }
}
function MtxGrid_Conditional_7_Conditional_5_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r43 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr", 58);
    ɵɵpipe(1, "rowClass");
    ɵɵlistener("click", function MtxGrid_Conditional_7_Conditional_5_tr_0_Template_tr_click_0_listener($event) {
      const ctx_r43 = ɵɵrestoreView(_r43);
      const row_r45 = ctx_r43.$implicit;
      const index_r46 = ctx_r43.index;
      const dataIndex_r47 = ctx_r43.dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0._selectRow($event, row_r45, ctx_r0._getIndex(index_r46, dataIndex_r47)));
    })("contextmenu", function MtxGrid_Conditional_7_Conditional_5_tr_0_Template_tr_contextmenu_0_listener($event) {
      const ctx_r47 = ɵɵrestoreView(_r43);
      const row_r45 = ctx_r47.$implicit;
      const index_r46 = ctx_r47.index;
      const dataIndex_r47 = ctx_r47.dataIndex;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0._contextmenu($event, row_r45, ctx_r0._getIndex(index_r46, dataIndex_r47)));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r45 = ctx.$implicit;
    const index_r46 = ctx.index;
    const dataIndex_r47 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassMap(ɵɵpipeBind4(1, 4, row_r45, index_r46, dataIndex_r47, ctx_r0.rowClassFormatter));
    ɵɵclassProp("selected", ctx_r0.rowSelection.isSelected(row_r45));
  }
}
function MtxGrid_Conditional_7_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_Conditional_5_tr_0_Template, 2, 9, "tr", 57);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matRowDefColumns", ctx_r0.displayedColumns);
  }
}
function MtxGrid_Conditional_7_Conditional_6_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 27);
  }
}
function MtxGrid_Conditional_7_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_7_Conditional_6_tr_0_Template, 1, 0, "tr", 59);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("matFooterRowDef", ctx_r0.displayedColumns)("matFooterRowDefSticky", true);
  }
}
function MtxGrid_Conditional_7_Conditional_7_td_1_ng_template_3_Template(rf, ctx) {
}
function MtxGrid_Conditional_7_Conditional_7_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 63)(1, "div", 64)(2, "div", 65);
    ɵɵtemplate(3, MtxGrid_Conditional_7_Conditional_7_td_1_ng_template_3_Template, 0, 0, "ng-template", 43);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const row_r49 = ctx.$implicit;
    const dataIndex_r50 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵattribute("colspan", ctx_r0.displayedColumns.length);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.expansionTemplate)("ngTemplateOutletContext", ɵɵpureFunction4(3, _c10, row_r49, row_r49, dataIndex_r50, ctx_r0.expansionRowStates[dataIndex_r50].expanded));
  }
}
function MtxGrid_Conditional_7_Conditional_7_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 66);
  }
  if (rf & 2) {
    const dataIndex_r51 = ctx.dataIndex;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassMap(ctx_r0.expansionRowStates[dataIndex_r51].expanded ? "expanded" : "collapsed");
  }
}
function MtxGrid_Conditional_7_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 60);
    ɵɵtemplate(1, MtxGrid_Conditional_7_Conditional_7_td_1_Template, 4, 8, "td", 61);
    ɵɵelementContainerEnd();
    ɵɵtemplate(2, MtxGrid_Conditional_7_Conditional_7_tr_2_Template, 1, 2, "tr", 62);
  }
  if (rf & 2) {
    ɵɵadvance(2);
    ɵɵproperty("matRowDefColumns", ɵɵpureFunction0(1, _c9));
  }
}
function MtxGrid_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "table", 67);
    ɵɵlistener("matSortChange", function MtxGrid_Conditional_7_Template_table_matSortChange_0_listener($event) {
      ɵɵrestoreView(_r28);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0._onSortChange($event));
    });
    ɵɵconditionalCreate(1, MtxGrid_Conditional_7_Conditional_1_Template, 4, 0, "ng-container", 23);
    ɵɵrepeaterCreate(2, MtxGrid_Conditional_7_For_3_Template, 4, 3, "ng-container", 24, _forTrack0);
    ɵɵconditionalCreate(4, MtxGrid_Conditional_7_Conditional_4_Template, 1, 2, "tr", 25);
    ɵɵconditionalCreate(5, MtxGrid_Conditional_7_Conditional_5_Template, 1, 1, "tr", 26);
    ɵɵconditionalCreate(6, MtxGrid_Conditional_7_Conditional_6_Template, 1, 2, "tr", 27);
    ɵɵconditionalCreate(7, MtxGrid_Conditional_7_Conditional_7_Template, 3, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("mat-table-hover", ctx_r0.rowHover)("mat-table-striped", ctx_r0.rowStriped)("mat-table-expandable", ctx_r0.expandable);
    ɵɵproperty("dataSource", ctx_r0.dataSource)("multiTemplateDataRows", ctx_r0.expandable)("matSortActive", ctx_r0.sortActive)("matSortDirection", ctx_r0.sortDirection)("matSortDisableClear", ctx_r0.sortDisableClear)("matSortDisabled", ctx_r0.sortDisabled)("matSortStart", ctx_r0.sortStart)("trackBy", ctx_r0.trackBy);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.rowSelectable && !ctx_r0.hideRowSelectionCheckbox ? 1 : -1);
    ɵɵadvance();
    ɵɵrepeater(ctx_r0.columns);
    ɵɵadvance(2);
    ɵɵconditional(!ctx_r0.useContentHeaderRowTemplate ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(!ctx_r0.useContentRowTemplate ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0._whetherShowSummary ? 6 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.expandable ? 7 : -1);
  }
}
function MtxGrid_Conditional_8_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_8_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_8_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.noResultTemplate);
  }
}
function MtxGrid_Conditional_8_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r0.noResultText, " ");
  }
}
function MtxGrid_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_8_Conditional_1_Template, 1, 1, null, 14)(2, MtxGrid_Conditional_8_Conditional_2_Template, 1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r0.noResultTemplate ? 1 : 2);
  }
}
function MtxGrid_Conditional_9_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_9_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_9_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.sidebarTemplate);
  }
}
function MtxGrid_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_9_Conditional_1_Template, 1, 1, null, 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r0.sidebarTemplate ? 1 : -1);
  }
}
function MtxGrid_Conditional_11_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_11_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_11_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.statusbarTemplate);
  }
}
function MtxGrid_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵconditionalCreate(1, MtxGrid_Conditional_11_Conditional_1_Template, 1, 1, null, 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r0.statusbarTemplate ? 1 : -1);
  }
}
function MtxGrid_Conditional_13_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_Conditional_13_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.paginationTemplate);
  }
}
function MtxGrid_Conditional_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r52 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-paginator", 72);
    ɵɵlistener("page", function MtxGrid_Conditional_14_Template_mat_paginator_page_0_listener($event) {
      ɵɵrestoreView(_r52);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0._onPage($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("mat-paginator-hidden", !ctx_r0.showPaginator);
    ɵɵproperty("showFirstLastButtons", ctx_r0.showFirstLastButtons)("length", ctx_r0.length)("pageIndex", ctx_r0.pageIndex)("pageSize", ctx_r0.pageSize)("pageSizeOptions", ctx_r0.pageSizeOptions)("hidePageSize", ctx_r0.hidePageSize)("disabled", ctx_r0.pageDisabled);
  }
}
function MtxGrid_ng_template_15_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_ng_template_15_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_ng_template_15_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const ctx_r52 = ɵɵnextContext();
    const headerExtraTemplate_r54 = ctx_r52.$implicit;
    const col_r55 = ctx_r52.colDef;
    ɵɵproperty("ngTemplateOutlet", headerExtraTemplate_r54)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c5, col_r55, col_r55));
  }
}
function MtxGrid_ng_template_15_Conditional_2_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function MtxGrid_ng_template_15_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MtxGrid_ng_template_15_Conditional_2_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 43);
  }
  if (rf & 2) {
    const ctx_r52 = ɵɵnextContext(2);
    const headerExtraTemplate_r54 = ctx_r52.$implicit;
    const col_r55 = ctx_r52.colDef;
    ɵɵproperty("ngTemplateOutlet", headerExtraTemplate_r54[col_r55.field])("ngTemplateOutletContext", ɵɵpureFunction2(2, _c5, col_r55, col_r55));
  }
}
function MtxGrid_ng_template_15_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_ng_template_15_Conditional_2_Conditional_0_Template, 1, 5, null, 43);
    ɵɵpipe(1, "isTemplateRef");
  }
  if (rf & 2) {
    const ctx_r52 = ɵɵnextContext();
    const headerExtraTemplate_r54 = ctx_r52.$implicit;
    const col_r55 = ctx_r52.colDef;
    ɵɵconditional(ɵɵpipeBind1(1, 1, headerExtraTemplate_r54 == null ? null : headerExtraTemplate_r54[col_r55.field]) ? 0 : -1);
  }
}
function MtxGrid_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, MtxGrid_ng_template_15_Conditional_0_Template, 1, 5, null, 43);
    ɵɵpipe(1, "isTemplateRef");
    ɵɵconditionalBranchCreate(2, MtxGrid_ng_template_15_Conditional_2_Template, 2, 3);
  }
  if (rf & 2) {
    const headerExtraTemplate_r54 = ctx.$implicit;
    ɵɵconditional(ɵɵpipeBind1(1, 1, headerExtraTemplate_r54) ? 0 : 2);
  }
}
var _MatFlexTableResizeStrategy = class _MatFlexTableResizeStrategy extends CdkFlexTableResizeStrategy {
  getColumnCssClass(cssFriendlyColumnName) {
    return `mat-column-${cssFriendlyColumnName}`;
  }
};
_MatFlexTableResizeStrategy.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatFlexTableResizeStrategy_BaseFactory;
  return function MatFlexTableResizeStrategy_Factory(__ngFactoryType__) {
    return (ɵMatFlexTableResizeStrategy_BaseFactory || (ɵMatFlexTableResizeStrategy_BaseFactory = ɵɵgetInheritedFactory(_MatFlexTableResizeStrategy)))(__ngFactoryType__ || _MatFlexTableResizeStrategy);
  };
})();
_MatFlexTableResizeStrategy.ɵprov = ɵɵdefineInjectable({
  token: _MatFlexTableResizeStrategy,
  factory: _MatFlexTableResizeStrategy.ɵfac
});
var MatFlexTableResizeStrategy = _MatFlexTableResizeStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatFlexTableResizeStrategy, [{
    type: Injectable
  }], null, null);
})();
var FLEX_RESIZE_STRATEGY_PROVIDER2 = {
  provide: ResizeStrategy,
  useClass: MatFlexTableResizeStrategy
};
var PROVIDERS2 = [ColumnResizeNotifier, HeaderRowEventDispatcher, ColumnResizeNotifierSource, {
  provide: _COALESCED_STYLE_SCHEDULER,
  useClass: _CoalescedStyleScheduler
}];
var TABLE_PROVIDERS2 = [...PROVIDERS2, TABLE_LAYOUT_FIXED_RESIZE_STRATEGY_PROVIDER];
var FLEX_PROVIDERS2 = [...PROVIDERS2, FLEX_RESIZE_STRATEGY_PROVIDER2];
var TABLE_HOST_BINDINGS = {
  class: "mat-column-resize-table"
};
var FLEX_HOST_BINDINGS = {
  class: "mat-column-resize-flex"
};
var AbstractMatColumnResize = class extends ColumnResize {
  getTableHeight() {
    const table = this.elementRef.nativeElement;
    const tableParent = table.parentNode;
    const isTableContainer = tableParent.classList.contains("mat-table-container");
    return isTableContainer ? tableParent.offsetHeight : table.offsetHeight;
  }
};
var _MatColumnResize = class _MatColumnResize extends AbstractMatColumnResize {
  constructor() {
    super(...arguments);
    this.columnResizeNotifier = inject(ColumnResizeNotifier);
    this.elementRef = inject(ElementRef);
    this.eventDispatcher = inject(HeaderRowEventDispatcher);
    this.ngZone = inject(NgZone);
    this.notifier = inject(ColumnResizeNotifierSource);
  }
};
_MatColumnResize.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatColumnResize_BaseFactory;
  return function MatColumnResize_Factory(__ngFactoryType__) {
    return (ɵMatColumnResize_BaseFactory || (ɵMatColumnResize_BaseFactory = ɵɵgetInheritedFactory(_MatColumnResize)))(__ngFactoryType__ || _MatColumnResize);
  };
})();
_MatColumnResize.ɵdir = ɵɵdefineDirective({
  type: _MatColumnResize,
  selectors: [["table", "mat-table", "", "columnResize", ""]],
  hostAttrs: [1, "mat-column-resize-table"],
  features: [ɵɵProvidersFeature([...TABLE_PROVIDERS2, {
    provide: ColumnResize,
    useExisting: _MatColumnResize
  }]), ɵɵInheritDefinitionFeature]
});
var MatColumnResize = _MatColumnResize;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnResize, [{
    type: Directive,
    args: [{
      selector: "table[mat-table][columnResize]",
      host: TABLE_HOST_BINDINGS,
      providers: [...TABLE_PROVIDERS2, {
        provide: ColumnResize,
        useExisting: MatColumnResize
      }]
    }]
  }], null, null);
})();
var _MatColumnResizeFlex = class _MatColumnResizeFlex extends AbstractMatColumnResize {
  constructor() {
    super(...arguments);
    this.columnResizeNotifier = inject(ColumnResizeNotifier);
    this.elementRef = inject(ElementRef);
    this.eventDispatcher = inject(HeaderRowEventDispatcher);
    this.ngZone = inject(NgZone);
    this.notifier = inject(ColumnResizeNotifierSource);
  }
};
_MatColumnResizeFlex.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatColumnResizeFlex_BaseFactory;
  return function MatColumnResizeFlex_Factory(__ngFactoryType__) {
    return (ɵMatColumnResizeFlex_BaseFactory || (ɵMatColumnResizeFlex_BaseFactory = ɵɵgetInheritedFactory(_MatColumnResizeFlex)))(__ngFactoryType__ || _MatColumnResizeFlex);
  };
})();
_MatColumnResizeFlex.ɵdir = ɵɵdefineDirective({
  type: _MatColumnResizeFlex,
  selectors: [["mat-table", "columnResize", ""]],
  hostAttrs: [1, "mat-column-resize-flex"],
  features: [ɵɵProvidersFeature([...FLEX_PROVIDERS2, {
    provide: ColumnResize,
    useExisting: _MatColumnResizeFlex
  }]), ɵɵInheritDefinitionFeature]
});
var MatColumnResizeFlex = _MatColumnResizeFlex;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnResizeFlex, [{
    type: Directive,
    args: [{
      selector: "mat-table[columnResize]",
      host: FLEX_HOST_BINDINGS,
      providers: [...FLEX_PROVIDERS2, {
        provide: ColumnResize,
        useExisting: MatColumnResizeFlex
      }]
    }]
  }], null, null);
})();
var _MatColumnResizeOverlayHandle = class _MatColumnResizeOverlayHandle extends ResizeOverlayHandle {
  constructor() {
    super(...arguments);
    this.columnDef = inject(CdkColumnDef);
    this.columnResize = inject(ColumnResize);
    this.directionality = inject(Directionality);
    this.elementRef = inject(ElementRef);
    this.eventDispatcher = inject(HeaderRowEventDispatcher);
    this.ngZone = inject(NgZone);
    this.resizeNotifier = inject(ColumnResizeNotifierSource);
    this.resizeRef = inject(ResizeRef);
    this.styleScheduler = inject(_COALESCED_STYLE_SCHEDULER);
    this.document = inject(DOCUMENT);
  }
  updateResizeActive(active) {
    super.updateResizeActive(active);
    const originHeight = this.resizeRef.origin.nativeElement.offsetHeight;
    this.topElement.nativeElement.style.height = `${originHeight}px`;
    this.resizeRef.overlayRef.updateSize({
      height: active ? this.columnResize.getTableHeight() : originHeight
    });
  }
};
_MatColumnResizeOverlayHandle.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatColumnResizeOverlayHandle_BaseFactory;
  return function MatColumnResizeOverlayHandle_Factory(__ngFactoryType__) {
    return (ɵMatColumnResizeOverlayHandle_BaseFactory || (ɵMatColumnResizeOverlayHandle_BaseFactory = ɵɵgetInheritedFactory(_MatColumnResizeOverlayHandle)))(__ngFactoryType__ || _MatColumnResizeOverlayHandle);
  };
})();
_MatColumnResizeOverlayHandle.ɵcmp = ɵɵdefineComponent({
  type: _MatColumnResizeOverlayHandle,
  selectors: [["ng-component"]],
  viewQuery: function MatColumnResizeOverlayHandle_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.topElement = _t.first);
    }
  },
  hostAttrs: [1, "mat-column-resize-overlay-thumb"],
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 0,
  consts: [["top", ""], [1, "mat-column-resize-overlay-thumb-top"]],
  template: function MatColumnResizeOverlayHandle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵdomElement(0, "div", 1, 0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var MatColumnResizeOverlayHandle = _MatColumnResizeOverlayHandle;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnResizeOverlayHandle, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        class: "mat-column-resize-overlay-thumb"
      },
      template: '<div #top class="mat-column-resize-overlay-thumb-top"></div>'
    }]
  }], null, {
    topElement: [{
      type: ViewChild,
      args: ["top", {
        static: true
      }]
    }]
  });
})();
var AbstractMatResizable = class extends Resizable {
  constructor() {
    super(...arguments);
    this.minWidthPxInternal = 32;
  }
  getInlineHandleCssClassName() {
    return "mat-resizable-handle";
  }
  getOverlayHandleComponentType() {
    return MatColumnResizeOverlayHandle;
  }
};
var RESIZABLE_HOST_BINDINGS = {
  class: "mat-resizable"
};
var RESIZABLE_INPUTS = ["minWidthPx: matResizableMinWidthPx", "maxWidthPx: matResizableMaxWidthPx"];
var _MatResizable = class _MatResizable extends AbstractMatResizable {
  constructor() {
    super(...arguments);
    this.columnDef = inject(CdkColumnDef);
    this.columnResize = inject(ColumnResize);
    this.directionality = inject(Directionality);
    this.elementRef = inject(ElementRef);
    this.eventDispatcher = inject(HeaderRowEventDispatcher);
    this.injector = inject(Injector);
    this.ngZone = inject(NgZone);
    this.overlay = inject(Overlay);
    this.resizeNotifier = inject(ColumnResizeNotifierSource);
    this.resizeStrategy = inject(ResizeStrategy);
    this.styleScheduler = inject(_COALESCED_STYLE_SCHEDULER);
    this.viewContainerRef = inject(ViewContainerRef);
    this.changeDetectorRef = inject(ChangeDetectorRef);
    this.document = inject(DOCUMENT);
    this.isResizable = true;
  }
  get resizableClass() {
    return this.isResizable ? RESIZABLE_HOST_BINDINGS.class : "";
  }
  get resizable() {
    return this.isResizable;
  }
  set resizable(newValue) {
    this.isResizable = newValue == null || newValue === "" || newValue;
  }
};
_MatResizable.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatResizable_BaseFactory;
  return function MatResizable_Factory(__ngFactoryType__) {
    return (ɵMatResizable_BaseFactory || (ɵMatResizable_BaseFactory = ɵɵgetInheritedFactory(_MatResizable)))(__ngFactoryType__ || _MatResizable);
  };
})();
_MatResizable.ɵdir = ɵɵdefineDirective({
  type: _MatResizable,
  selectors: [["mat-header-cell", "resizable", ""], ["th", "mat-header-cell", "", "resizable", ""]],
  hostVars: 2,
  hostBindings: function MatResizable_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.resizableClass);
    }
  },
  inputs: {
    minWidthPx: [0, "matResizableMinWidthPx", "minWidthPx"],
    maxWidthPx: [0, "matResizableMaxWidthPx", "maxWidthPx"],
    resizable: "resizable"
  },
  features: [ɵɵInheritDefinitionFeature]
});
var MatResizable = _MatResizable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatResizable, [{
    type: Directive,
    args: [{
      selector: "mat-header-cell[resizable], th[mat-header-cell][resizable]",
      host: {
        "[class]": "resizableClass"
      },
      inputs: RESIZABLE_INPUTS
    }]
  }], null, {
    resizable: [{
      type: Input
    }]
  });
})();
var ENTRY_COMMON_COMPONENTS = [MatColumnResizeOverlayHandle];
var _MatColumnResizeCommonModule = class _MatColumnResizeCommonModule {
};
_MatColumnResizeCommonModule.ɵfac = function MatColumnResizeCommonModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MatColumnResizeCommonModule)();
};
_MatColumnResizeCommonModule.ɵmod = ɵɵdefineNgModule({
  type: _MatColumnResizeCommonModule,
  imports: [MatColumnResizeOverlayHandle],
  exports: [MatColumnResizeOverlayHandle]
});
_MatColumnResizeCommonModule.ɵinj = ɵɵdefineInjector({});
var MatColumnResizeCommonModule = _MatColumnResizeCommonModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnResizeCommonModule, [{
    type: NgModule,
    args: [{
      imports: ENTRY_COMMON_COMPONENTS,
      exports: ENTRY_COMMON_COMPONENTS
    }]
  }], null, null);
})();
var IMPORTS = [MatCommonModule, OverlayModule, MatColumnResizeCommonModule];
var _MatColumnResizeModule = class _MatColumnResizeModule {
};
_MatColumnResizeModule.ɵfac = function MatColumnResizeModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MatColumnResizeModule)();
};
_MatColumnResizeModule.ɵmod = ɵɵdefineNgModule({
  type: _MatColumnResizeModule,
  imports: [MatCommonModule, OverlayModule, MatColumnResizeCommonModule, MatColumnResize, MatColumnResizeFlex, MatResizable],
  exports: [MatColumnResize, MatColumnResizeFlex, MatResizable]
});
_MatColumnResizeModule.ɵinj = ɵɵdefineInjector({
  imports: [IMPORTS]
});
var MatColumnResizeModule = _MatColumnResizeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnResizeModule, [{
    type: NgModule,
    args: [{
      imports: [...IMPORTS, MatColumnResize, MatColumnResizeFlex, MatResizable],
      exports: [MatColumnResize, MatColumnResizeFlex, MatResizable]
    }]
  }], null, null);
})();
var _MtxGridUtils = class _MtxGridUtils {
  constructor() {
  }
  /**
   * Get cell's value based on the data and column's field (e.g. `a.b.c`)
   * @param rowData Row data
   * @param colDef Column definition
   * @returns
   */
  getCellValue(rowData, colDef) {
    const keyArr = colDef.field ? colDef.field.split(".") : [];
    let tmp = "";
    keyArr.forEach((key, i) => {
      if (i === 0) {
        tmp = rowData[key];
      } else {
        tmp = tmp && tmp[key];
      }
    });
    return tmp;
  }
  /**
   * Get all data of a col
   * @param data All data
   * @param colDef Column definition
   * @returns
   */
  getColData(data, colDef) {
    return data.map((rowData) => this.getCellValue(rowData, colDef));
  }
  /**
   * Whether the value is empty (`null`, `undefined`, `''`, `[]`)
   * @param value
   * @returns
   */
  isEmpty(value) {
    return value == null || value.toString() === "";
  }
  /**
   * Whether the value contain HTML
   * @param value
   * @returns
   */
  isContainHTML(value) {
    return /<\/?[a-z][\s\S]*>/i.test(value);
  }
};
_MtxGridUtils.ɵfac = function MtxGridUtils_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridUtils)();
};
_MtxGridUtils.ɵprov = ɵɵdefineInjectable({
  token: _MtxGridUtils,
  factory: _MtxGridUtils.ɵfac,
  providedIn: "root"
});
var MtxGridUtils = _MtxGridUtils;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridUtils, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var _MtxGridColClassPipe = class _MtxGridColClassPipe {
  transform(colDef, rowData, rowChangeRecord, currentValue) {
    if (typeof colDef.class === "string") {
      return colDef.class;
    } else if (typeof colDef.class === "function") {
      return colDef.class(rowData, colDef);
    }
    return "";
  }
};
_MtxGridColClassPipe.ɵfac = function MtxGridColClassPipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridColClassPipe)();
};
_MtxGridColClassPipe.ɵpipe = ɵɵdefinePipe({
  name: "colClass",
  type: _MtxGridColClassPipe,
  pure: true
});
var MtxGridColClassPipe = _MtxGridColClassPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridColClassPipe, [{
    type: Pipe,
    args: [{
      name: "colClass"
    }]
  }], null, null);
})();
var _MtxGridRowClassPipe = class _MtxGridRowClassPipe {
  transform(rowData, index, dataIndex, rowClassFormatter) {
    const rowIndex = index === void 0 ? dataIndex : index;
    const classList = rowIndex % 2 === 1 ? ["mat-row-odd"] : [];
    if (rowClassFormatter) {
      for (const key of Object.keys(rowClassFormatter)) {
        if (rowClassFormatter[key](rowData, rowIndex)) {
          classList.push(key);
        }
      }
    }
    return classList.join(" ");
  }
};
_MtxGridRowClassPipe.ɵfac = function MtxGridRowClassPipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridRowClassPipe)();
};
_MtxGridRowClassPipe.ɵpipe = ɵɵdefinePipe({
  name: "rowClass",
  type: _MtxGridRowClassPipe,
  pure: true
});
var MtxGridRowClassPipe = _MtxGridRowClassPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridRowClassPipe, [{
    type: Pipe,
    args: [{
      name: "rowClass"
    }]
  }], null, null);
})();
var _MtxGridCellActionsPipe = class _MtxGridCellActionsPipe {
  transform(btns, rowData, rowChangeRecord, currentValue) {
    if (typeof btns === "function") {
      return btns(rowData);
    } else if (Array.isArray(btns)) {
      return btns;
    }
    return [];
  }
};
_MtxGridCellActionsPipe.ɵfac = function MtxGridCellActionsPipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridCellActionsPipe)();
};
_MtxGridCellActionsPipe.ɵpipe = ɵɵdefinePipe({
  name: "cellActions",
  type: _MtxGridCellActionsPipe,
  pure: true
});
var MtxGridCellActionsPipe = _MtxGridCellActionsPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCellActionsPipe, [{
    type: Pipe,
    args: [{
      name: "cellActions"
    }]
  }], null, null);
})();
var _MtxGridCellActionTooltipPipe = class _MtxGridCellActionTooltipPipe {
  transform(btn) {
    if (typeof btn.tooltip === "string" || isObservable(btn.tooltip)) {
      return {
        message: btn.tooltip
      };
    } else {
      return btn.tooltip || {
        message: ""
      };
    }
  }
};
_MtxGridCellActionTooltipPipe.ɵfac = function MtxGridCellActionTooltipPipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridCellActionTooltipPipe)();
};
_MtxGridCellActionTooltipPipe.ɵpipe = ɵɵdefinePipe({
  name: "cellActionTooltip",
  type: _MtxGridCellActionTooltipPipe,
  pure: true
});
var MtxGridCellActionTooltipPipe = _MtxGridCellActionTooltipPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCellActionTooltipPipe, [{
    type: Pipe,
    args: [{
      name: "cellActionTooltip"
    }]
  }], null, null);
})();
var _MtxGridCellActionBadgePipe = class _MtxGridCellActionBadgePipe {
  transform(btn) {
    if (typeof btn.badge === "number" || typeof btn.badge === "string" || isObservable(btn.badge)) {
      return {
        content: btn.badge
      };
    } else {
      return btn.badge || {
        content: ""
      };
    }
  }
};
_MtxGridCellActionBadgePipe.ɵfac = function MtxGridCellActionBadgePipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridCellActionBadgePipe)();
};
_MtxGridCellActionBadgePipe.ɵpipe = ɵɵdefinePipe({
  name: "cellActionBadge",
  type: _MtxGridCellActionBadgePipe,
  pure: true
});
var MtxGridCellActionBadgePipe = _MtxGridCellActionBadgePipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCellActionBadgePipe, [{
    type: Pipe,
    args: [{
      name: "cellActionBadge"
    }]
  }], null, null);
})();
var _MtxGridCellActionDisablePipe = class _MtxGridCellActionDisablePipe {
  transform(btn, rowData, rowChangeRecord, currentValue) {
    if (typeof btn.disabled === "boolean") {
      return btn.disabled;
    } else if (typeof btn.disabled === "function") {
      return btn.disabled(rowData);
    } else {
      return false;
    }
  }
};
_MtxGridCellActionDisablePipe.ɵfac = function MtxGridCellActionDisablePipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridCellActionDisablePipe)();
};
_MtxGridCellActionDisablePipe.ɵpipe = ɵɵdefinePipe({
  name: "cellActionDisable",
  type: _MtxGridCellActionDisablePipe,
  pure: true
});
var MtxGridCellActionDisablePipe = _MtxGridCellActionDisablePipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCellActionDisablePipe, [{
    type: Pipe,
    args: [{
      name: "cellActionDisable"
    }]
  }], null, null);
})();
var _MtxGridCellSummaryPipe = class _MtxGridCellSummaryPipe {
  constructor() {
    this.utils = inject(MtxGridUtils);
  }
  transform(data, colDef) {
    if (typeof colDef.summary === "string") {
      return colDef.summary;
    } else if (typeof colDef.summary === "function") {
      return colDef.summary(this.utils.getColData(data, colDef), colDef);
    }
  }
};
_MtxGridCellSummaryPipe.ɵfac = function MtxGridCellSummaryPipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridCellSummaryPipe)();
};
_MtxGridCellSummaryPipe.ɵpipe = ɵɵdefinePipe({
  name: "cellSummary",
  type: _MtxGridCellSummaryPipe,
  pure: true
});
var MtxGridCellSummaryPipe = _MtxGridCellSummaryPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCellSummaryPipe, [{
    type: Pipe,
    args: [{
      name: "cellSummary"
    }]
  }], null, null);
})();
var _MtxGridMenu = class _MtxGridMenu {
  constructor() {
    this.items = [];
    this.data = {};
  }
};
_MtxGridMenu.ɵfac = function MtxGridMenu_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridMenu)();
};
_MtxGridMenu.ɵcmp = ɵɵdefineComponent({
  type: _MtxGridMenu,
  selectors: [["mtx-grid-menu"]],
  viewQuery: function MtxGridMenu_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(MatMenu, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menu = _t.first);
    }
  },
  inputs: {
    items: "items",
    data: "data"
  },
  exportAs: ["mtxGridMenu"],
  decls: 5,
  vars: 0,
  consts: [["iconTpl", ""], ["gridMenu", ""], [1, "mtx-grid-menu"], ["mat-menu-item", "", 3, "disabled", "class"], ["mat-menu-item", "", 3, "click", "matMenuTriggerFor", "disabled"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "items", "data"], ["mat-menu-item", "", 3, "click", "disabled"], [1, "mtx-grid-icon"], [1, "mtx-grid-icon", 3, "fontIcon"], [1, "mtx-grid-icon", 3, "svgIcon"]],
  template: function MtxGridMenu_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "mat-menu", 2);
      ɵɵrepeaterCreate(1, MtxGridMenu_For_2_Template, 1, 1, null, null, ɵɵrepeaterTrackByIndex);
      ɵɵelementEnd();
      ɵɵtemplate(3, MtxGridMenu_ng_template_3_Template, 3, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵrepeater(ctx.items);
    }
  },
  dependencies: [_MtxGridMenu, NgTemplateOutlet, MatMenu, MatMenuItem, MatMenuTrigger, MatIcon, MtxGridCellActionDisablePipe],
  encapsulation: 2,
  changeDetection: 0
});
var MtxGridMenu = _MtxGridMenu;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridMenu, [{
    type: Component,
    args: [{
      selector: "mtx-grid-menu",
      exportAs: "mtxGridMenu",
      template: `
    <mat-menu class="mtx-grid-menu">
      @for (item of items; track $index) {
        @if (!item.iif || item.iif(data)) {
          @if (item.children && item.children.length > 0) {
            <button
              mat-menu-item
              [matMenuTriggerFor]="gridMenu.menu"
              [disabled]="item | cellActionDisable: data"
              [class]="item.class"
              (click)="item.click?.(data)"
            >
              <mat-icon *ngTemplateOutlet="iconTpl; context: { $implicit: item }" />
              <span>{{ item.text }}</span>
            </button>

            <mtx-grid-menu #gridMenu [items]="item.children" [data]="data" />
          } @else {
            <button
              mat-menu-item
              [disabled]="item | cellActionDisable: data"
              [class]="item.class"
              (click)="item.click?.(data)"
            >
              <mat-icon *ngTemplateOutlet="iconTpl; context: { $implicit: item }" />
              <span>{{ item.text }}</span>
            </button>
          }
        }
      }
    </mat-menu>

    <ng-template #iconTpl let-item>
      @if (item.icon) {
        <mat-icon class="mtx-grid-icon">{{ item.icon }}</mat-icon>
      } @else if (item.fontIcon) {
        <mat-icon class="mtx-grid-icon" [fontIcon]="item.fontIcon"></mat-icon>
      } @else if (item.svgIcon) {
        <mat-icon class="mtx-grid-icon" [svgIcon]="item.svgIcon"></mat-icon>
      }
    </ng-template>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [NgTemplateOutlet, MatMenu, MatMenuItem, MatMenuTrigger, MatIcon, MtxGridMenu, MtxGridCellActionDisablePipe]
    }]
  }], null, {
    menu: [{
      type: ViewChild,
      args: [MatMenu, {
        static: true
      }]
    }],
    items: [{
      type: Input
    }],
    data: [{
      type: Input
    }]
  });
})();
var _MtxGridCell = class _MtxGridCell {
  constructor() {
    this._dialog = inject(MtxDialog);
    this._utils = inject(MtxGridUtils);
    this._differs = inject(KeyValueDiffers);
    this._changeDetectorRef = inject(ChangeDetectorRef);
    this.rowData = {};
    this.data = [];
    this.summary = false;
    this.placeholder = "--";
    this.rowDataChange = new EventEmitter();
  }
  get _value() {
    return this._utils.getCellValue(this.rowData, this.colDef);
  }
  ngOnInit() {
    this.rowDataDiffer = this._differs.find(this.rowData).create();
  }
  ngDoCheck() {
    const changes = this.rowDataDiffer?.diff(this.rowData);
    if (changes) {
      this._applyChanges(changes);
    }
  }
  _applyChanges(changes) {
    changes.forEachChangedItem((record) => {
      this.rowChangeRecord = record;
      this.rowDataChange.emit(record);
      this._changeDetectorRef.markForCheck();
    });
  }
  _getText(value) {
    return value === void 0 ? "" : this._utils.isEmpty(value) ? this.placeholder : value;
  }
  _getTooltip(value) {
    return this._utils.isEmpty(value) ? "" : value;
  }
  _getFormatterTooltip(value) {
    return this._utils.isContainHTML(value) || this._utils.isEmpty(value) ? "" : value;
  }
  _onActionClick(event, btn, rowData) {
    event.preventDefault();
    event.stopPropagation();
    if (typeof btn.pop === "string" || isObservable(btn.pop)) {
      this._dialog.open({
        title: btn.pop,
        buttons: [{
          color: "primary",
          text: "OK",
          onClick: () => btn.click?.(rowData) || {}
        }, {
          text: "CLOSE"
        }]
      });
    } else if (typeof btn.pop === "object") {
      this._dialog.open({
        title: btn.pop?.title,
        description: btn.pop?.description,
        buttons: [{
          color: btn.pop?.okColor || "primary",
          text: btn.pop?.okText || "OK",
          onClick: () => btn.click?.(rowData) || {}
        }, {
          color: btn.pop?.closeColor,
          text: btn.pop?.closeText || "CLOSE"
        }]
      });
    } else {
      btn.click?.(rowData);
    }
  }
};
_MtxGridCell.ɵfac = function MtxGridCell_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridCell)();
};
_MtxGridCell.ɵcmp = ɵɵdefineComponent({
  type: _MtxGridCell,
  selectors: [["mtx-grid-cell"]],
  inputs: {
    rowData: "rowData",
    colDef: "colDef",
    data: "data",
    summary: "summary",
    placeholder: "placeholder"
  },
  outputs: {
    rowDataChange: "rowDataChange"
  },
  exportAs: ["mtxGridCell"],
  decls: 4,
  vars: 1,
  consts: [["iconTpl", ""], ["gridMenu", ""], [3, "title", "innerHTML"], ["target", "_blank", 3, "href"], ["alt", "", 1, "mtx-grid-img", 3, "src"], [3, "title"], ["matIconButton", "", "type", "button", 1, "mtx-grid-action-button", 3, "click", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden", "matMenuTriggerFor"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "items", "data"], ["type", "button", 1, "mtx-grid-action-button", 3, "click", "matButton", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden", "matMenuTriggerFor"], ["matIconButton", "", "type", "button", 1, "mtx-grid-action-button", 3, "color", "class", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["type", "button", 1, "mtx-grid-action-button", 3, "matButton", "color", "class", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["matIconButton", "", "type", "button", 1, "mtx-grid-action-button", 3, "click", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["type", "button", 1, "mtx-grid-action-button", 3, "click", "matButton", "color", "disabled", "matTooltip", "matTooltipClass", "matTooltipHideDelay", "matTooltipShowDelay", "matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipTouchGestures", "matTooltipDisabled", "matBadge", "matBadgeDescription", "matBadgeColor", "matBadgePosition", "matBadgeSize", "matBadgeOverlap", "matBadgeDisabled", "matBadgeHidden"], ["color", "primary"], [1, "mtx-grid-icon"], [1, "mtx-grid-icon", 3, "fontIcon"], [1, "mtx-grid-icon", 3, "svgIcon"]],
  template: function MtxGridCell_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵconditionalCreate(0, MtxGridCell_Conditional_0_Template, 3, 8, "span", 2)(1, MtxGridCell_Conditional_1_Template, 2, 1);
      ɵɵtemplate(2, MtxGridCell_ng_template_2_Template, 3, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵconditional(ctx.summary ? 0 : 1);
    }
  },
  dependencies: [NgTemplateOutlet, MatButton, MatIconButton, MatIcon, MatChipListbox, MatChip, MatTooltip, MatBadge, MatMenuTrigger, MtxGridMenu, AsyncPipe, CurrencyPipe, DatePipe, DecimalPipe, PercentPipe, MtxToObservablePipe, MtxGridCellActionsPipe, MtxGridCellSummaryPipe, MtxGridCellActionDisablePipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe],
  styles: [".mtx-grid-img{display:inline-block;width:32px;border-radius:4px;vertical-align:middle}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var MtxGridCell = _MtxGridCell;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridCell, [{
    type: Component,
    args: [{
      selector: "mtx-grid-cell",
      exportAs: "mtxGridCell",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [AsyncPipe, CurrencyPipe, DatePipe, DecimalPipe, NgTemplateOutlet, PercentPipe, MatButton, MatIconButton, MatIcon, MatChipListbox, MatChip, MatTooltip, MatBadge, MatMenuTrigger, MtxToObservablePipe, MtxGridCellActionsPipe, MtxGridCellSummaryPipe, MtxGridCellActionDisablePipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe, MtxGridMenu],
      template: `@if (summary) {
  <span
    [title]="_getFormatterTooltip((data | cellSummary: colDef))"
    [innerHTML]="_getText((data | cellSummary: colDef))">
  </span>
} @else {
  <!-- Custom formatting -->
  @if (colDef.formatter) {
    <span
      [title]="_getFormatterTooltip(colDef.formatter(rowData, colDef))"
      [innerHTML]="_getText(colDef.formatter(rowData, colDef))">
    </span>
  } @else {
    <!-- Default formatting -->
    @switch (colDef.type) {
      <!-- Buttons -->
      @case ('button') {
        @for (btn of colDef.buttons | cellActions: rowData: rowChangeRecord: rowChangeRecord?.currentValue; track btn) {
          @if (!btn.iif || btn.iif(rowData)) {
            @if(btn.children && btn.children.length>0){
              @if (btn.type === 'icon') {
                <button
                  matIconButton
                  [color]="btn.color || 'primary'"
                  type="button"
                  class="mtx-grid-action-button"
                  [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData : rowChangeRecord : rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  [matMenuTriggerFor]="btn.children && btn.children.length>0 ? gridMenu.menu : null"
                  (click)="$event.stopPropagation()"
                >
                  <mat-icon *ngTemplateOutlet="iconTpl; context: { $implicit: btn }"></mat-icon>
                </button>

                <mtx-grid-menu #gridMenu [items]="btn.children || []" [data]="rowData" />
              } @else {
                <button
                  [matButton]="btn.type || 'text'"
                  [color]="btn.color || 'primary'"
                  type="button"
                  class="mtx-grid-action-button"
                  [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData : rowChangeRecord : rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  [matMenuTriggerFor]="btn.children && btn.children.length>0 ? gridMenu.menu : null"
                  (click)="$event.stopPropagation()"
                >
                  <mat-icon *ngTemplateOutlet="iconTpl; context: { $implicit: btn }"></mat-icon>
                  <span>{{ btn.text | toObservable | async }}</span>
                </button>

                <mtx-grid-menu #gridMenu [items]="btn.children || []" [data]="rowData" />
              }
            }@else {
              @if (btn.type === 'icon') {
                <button
                  matIconButton
                  [color]="btn.color || 'primary'"
                  type="button"
                  class="mtx-grid-action-button"
                  [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData : rowChangeRecord : rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  (click)="_onActionClick($event, btn, rowData)"
                >
                  <mat-icon *ngTemplateOutlet="iconTpl; context: { $implicit: btn }"></mat-icon>
                </button>
              } @else {
                <button
                  [matButton]="btn.type || 'text'"
                  [color]="btn.color || 'primary'"
                  type="button"
                  class="mtx-grid-action-button"
                  [class]="btn.class"
                  [disabled]="btn | cellActionDisable: rowData : rowChangeRecord : rowChangeRecord?.currentValue"
                  [matTooltip]="(btn | cellActionTooltip).message | toObservable | async"
                  [matTooltipClass]="(btn | cellActionTooltip).class"
                  [matTooltipHideDelay]="(btn | cellActionTooltip).hideDelay"
                  [matTooltipShowDelay]="(btn | cellActionTooltip).showDelay"
                  [matTooltipPosition]="(btn | cellActionTooltip).position || 'below'"
                  [matTooltipPositionAtOrigin]="(btn | cellActionTooltip).positionAtOrigin"
                  [matTooltipTouchGestures]="(btn | cellActionTooltip).touchGestures || 'auto'"
                  [matTooltipDisabled]="(btn | cellActionTooltip).disabled"
                  [matBadge]="(btn | cellActionBadge).content | toObservable | async"
                  [matBadgeDescription]="(btn | cellActionBadge).description | toObservable | async"
                  [matBadgeColor]="(btn | cellActionBadge).color"
                  [matBadgePosition]="(btn | cellActionBadge).position || 'above after'"
                  [matBadgeSize]="(btn | cellActionBadge).size || 'medium'"
                  [matBadgeOverlap]="(btn | cellActionBadge).overlap"
                  [matBadgeDisabled]="(btn | cellActionBadge).disabled"
                  [matBadgeHidden]="(btn | cellActionBadge).hidden"
                  (click)="_onActionClick($event, btn, rowData)"
                >
                  <mat-icon *ngTemplateOutlet="iconTpl; context: { $implicit: btn }"></mat-icon>
                  <span>{{ btn.text | toObservable | async }}</span>
                </button>
              }
            }
          }
        }
      }
      <!-- Tag -->
      @case ('tag') {
        @if (colDef.tag && colDef.tag[_value]) {
          <mat-chip-listbox>
            <mat-chip color="primary" [class]="'bg-' + colDef.tag[_value].color">
              {{colDef.tag[_value].text}}
            </mat-chip>
          </mat-chip-listbox>
        } @else {
          {{_value}}
        }
      }
      <!-- Link -->
      @case ('link') {
        <a [href]="_value" target="_blank">{{_value}}</a>
      }
      <!-- Image -->
      @case ('image') {
        <img class="mtx-grid-img" [src]="_value" alt="">
      }
      <!-- Boolean -->
      @case ('boolean') {
        <span [title]="_getTooltip(_value)">{{_getText(_value)}}</span>
      }
      <!-- Number -->
      @case ('number') {
        <span [title]="_getTooltip(_value | number: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)">
          {{_getText(_value | number: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)}}
        </span>
      }
      <!-- Currency -->
      @case ('currency') {
        <span [title]="_getTooltip(_value | currency: colDef.typeParameter?.currencyCode: colDef.typeParameter?.display: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)">
          {{_getText(_value | currency: colDef.typeParameter?.currencyCode: colDef.typeParameter?.display: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)}}
        </span>
      }
      <!-- Percent -->
      @case ('percent') {
        <span [title]="_getTooltip(_value | percent: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)">
          {{_getText(_value | percent: colDef.typeParameter?.digitsInfo: colDef.typeParameter?.locale)}}
        </span>
      }
      <!-- Date -->
      @case ('date') {
        <span [title]="_getTooltip(_value | date: colDef.typeParameter?.format: colDef.typeParameter?.timezone: colDef.typeParameter?.locale)">
          {{_getText(_value | date: colDef.typeParameter?.format: colDef.typeParameter?.timezone: colDef.typeParameter?.locale)}}
        </span>
      }
      <!-- Default -->
      @default {
        <span [title]="_getTooltip(_value)">{{_getText(_value)}}</span>
      }
    }
  }
}

<ng-template #iconTpl let-btn>
  @if (btn.icon) {
    <mat-icon class="mtx-grid-icon">{{btn.icon}}</mat-icon>
  } @else if(btn.fontIcon) {
    <mat-icon class="mtx-grid-icon" [fontIcon]="btn.fontIcon"></mat-icon>
  } @else if(btn.svgIcon) {
    <mat-icon class="mtx-grid-icon" [svgIcon]="btn.svgIcon"></mat-icon>
  }
</ng-template>
`,
      styles: [".mtx-grid-img{display:inline-block;width:32px;border-radius:4px;vertical-align:middle}\n"]
    }]
  }], null, {
    rowData: [{
      type: Input
    }],
    colDef: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    summary: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    rowDataChange: [{
      type: Output
    }]
  });
})();
var _MtxGridColumnMenu = class _MtxGridColumnMenu {
  constructor() {
    this.columns = [];
    this.selectable = true;
    this.selectableChecked = "show";
    this.sortable = true;
    this.pinnable = true;
    this._buttonText = "";
    this.buttonType = "outlined";
    this.buttonClass = "";
    this.buttonIcon = "";
    this.buttonFontIcon = "";
    this.buttonSvgIcon = "";
    this.showHeader = false;
    this.headerText = "Columns Header";
    this.showFooter = false;
    this.footerText = "Columns Footer";
    this.columnChange = new EventEmitter();
    this._pinOptions = [{
      label: "Pin Left",
      value: "left"
    }, {
      label: "Pin Right",
      value: "right"
    }, {
      label: "No Pin",
      value: null
    }];
  }
  get buttonText() {
    const defaultText = `Columns ${this.selectableChecked === "show" ? "Shown" : "Hidden"}`;
    return this._buttonText ? this._buttonText : defaultText;
  }
  set buttonText(value) {
    this._buttonText = value;
  }
  get pinOptions() {
    return this._pinOptions;
  }
  set pinOptions(value) {
    if (value.length > 0) {
      this._pinOptions = value;
    }
  }
  _handleDroped(e) {
    moveItemInArray(this.columns, e.previousIndex, e.currentIndex);
    this.columnChange.emit(this.columns);
  }
  _handleChecked(col) {
    if (this.selectableChecked === "show") {
      col.hide = !col.show;
    } else {
      col.show = !col.hide;
    }
    this.columnChange.emit(this.columns);
  }
  _handlePinSelect(col, val) {
    if (col.pinned != val) {
      col.pinned = val;
      this.columnChange.emit(this.columns);
    }
  }
};
_MtxGridColumnMenu.ɵfac = function MtxGridColumnMenu_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridColumnMenu)();
};
_MtxGridColumnMenu.ɵcmp = ɵɵdefineComponent({
  type: _MtxGridColumnMenu,
  selectors: [["mtx-grid-column-menu"]],
  viewQuery: function MtxGridColumnMenu_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(MatMenu, 7);
      ɵɵviewQuery(MatMenuTrigger, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuPanel = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuTrigger = _t.first);
    }
  },
  inputs: {
    columns: "columns",
    selectable: "selectable",
    selectableChecked: "selectableChecked",
    sortable: "sortable",
    pinnable: "pinnable",
    buttonText: "buttonText",
    buttonType: "buttonType",
    buttonColor: "buttonColor",
    buttonClass: "buttonClass",
    buttonIcon: "buttonIcon",
    buttonFontIcon: "buttonFontIcon",
    buttonSvgIcon: "buttonSvgIcon",
    showHeader: "showHeader",
    headerText: "headerText",
    headerTemplate: "headerTemplate",
    showFooter: "showFooter",
    footerText: "footerText",
    footerTemplate: "footerTemplate",
    pinOptions: "pinOptions"
  },
  outputs: {
    columnChange: "columnChange"
  },
  exportAs: ["mtxGridColumnMenu"],
  decls: 14,
  vars: 5,
  consts: [["iconTpl", ""], ["menu", "matMenu"], ["checkboxList", ""], ["pinList", "matMenu"], ["matIconButton", "", "type", "button", 3, "class", "color", "matMenuTriggerFor"], ["type", "button", 3, "class", "matButton", "color", "matMenuTriggerFor"], [1, "mtx-grid-column-menu"], [1, "mtx-grid-column-menu-content", 3, "click", "keydown"], [1, "mtx-grid-column-menu-header"], [1, "mtx-grid-column-menu-body"], ["cdkDropList", "", 1, "mtx-grid-column-menu-list"], [1, "mtx-grid-column-menu-list"], [1, "mtx-grid-column-menu-footer"], ["matIconButton", "", "type", "button", 3, "color", "matMenuTriggerFor"], [4, "ngTemplateOutlet"], ["type", "button", 3, "matButton", "color", "matMenuTriggerFor"], [3, "fontIcon"], [3, "svgIcon"], [3, "ngTemplateOutlet"], ["cdkDropList", "", 1, "mtx-grid-column-menu-list", 3, "cdkDropListDropped"], ["cdkDrag", "", 1, "mtx-grid-column-menu-item", 3, "cdkDragDisabled"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mtx-grid-column-drag-handle-icon"], ["d", "M7,19V17H9V19H7M11,19V17H13V19H11M15,19V17H17V19H15M7,15V13H9V15H7M11,15V13H13V15H11M15,15V13H17V15H15M7,11V9H9V11H7M11,11V9H13V11H11M15,11V9H17V11H15M7,7V5H9V7H7M11,7V5H13V7H11M15,7V5H17V7H15Z"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "mtx-grid-column-menu-item"], [1, "mtx-grid-column-menu-item-label", 3, "ngModel", "disabled"], [1, "mtx-grid-column-menu-item-label"], ["mat-icon-button", "", "type", "button", 1, "mtx-grid-column-pin-button", 3, "matMenuTriggerFor"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mtx-grid-column-pin-icon"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mtx-grid-column-pin-off-icon"], [1, "mtx-grid-column-pin-list"], ["type", "button", "mat-menu-item", "", 1, "mtx-grid-column-pin-option"], ["d", "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z"], ["d", "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z"], ["type", "button", "mat-menu-item", "", 1, "mtx-grid-column-pin-option", 3, "click"], [1, "mtx-grid-column-pin-option-placeholder"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mtx-grid-column-pin-check-icon"], [1, "mtx-grid-column-pin-option-text"], ["d", "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"], [1, "mtx-grid-column-menu-item-label", 3, "ngModelChange", "change", "ngModel", "disabled"]],
  template: function MtxGridColumnMenu_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵconditionalCreate(0, MtxGridColumnMenu_Conditional_0_Template, 2, 5, "button", 4)(1, MtxGridColumnMenu_Conditional_1_Template, 3, 7, "button", 5);
      ɵɵtemplate(2, MtxGridColumnMenu_ng_template_2_Template, 3, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      ɵɵelementStart(4, "mat-menu", 6, 1)(6, "div", 7);
      ɵɵlistener("click", function MtxGridColumnMenu_Template_div_click_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView($event.stopPropagation());
      })("keydown", function MtxGridColumnMenu_Template_div_keydown_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView($event.stopPropagation());
      });
      ɵɵconditionalCreate(7, MtxGridColumnMenu_Conditional_7_Template, 3, 1, "div", 8);
      ɵɵelementStart(8, "div", 9);
      ɵɵconditionalCreate(9, MtxGridColumnMenu_Conditional_9_Template, 3, 0, "div", 10);
      ɵɵconditionalCreate(10, MtxGridColumnMenu_Conditional_10_Template, 3, 0, "div", 11);
      ɵɵelementEnd();
      ɵɵconditionalCreate(11, MtxGridColumnMenu_Conditional_11_Template, 3, 1, "div", 12);
      ɵɵelementEnd()();
      ɵɵtemplate(12, MtxGridColumnMenu_ng_template_12_Template, 3, 2, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵconditional(ctx.buttonType === "icon" ? 0 : 1);
      ɵɵadvance(7);
      ɵɵconditional(ctx.showHeader ? 7 : -1);
      ɵɵadvance(2);
      ɵɵconditional(ctx.sortable ? 9 : -1);
      ɵɵadvance();
      ɵɵconditional(!ctx.sortable ? 10 : -1);
      ɵɵadvance();
      ɵɵconditional(ctx.showFooter ? 11 : -1);
    }
  },
  dependencies: [NgTemplateOutlet, FormsModule, NgControlStatus, NgModel, MatButton, MatIconButton, MatIcon, MatMenu, MatMenuTrigger, MatMenuItem, MatCheckbox, CdkDrag, CdkDropList, AsyncPipe, MtxToObservablePipe],
  styles: [".mtx-grid-column-menu,.mtx-grid-column-pin-list{color:var(--mtx-grid-column-menu-text-color, var(--mat-sys-on-surface-variant))}.mtx-grid-column-menu .mat-mdc-menu-content{padding:0}.mtx-grid-column-menu-body{max-height:65vh;padding:8px 16px;overflow:auto}.mtx-grid-column-menu-header,.mtx-grid-column-menu-footer{position:sticky;z-index:1;padding:8px 16px}.mtx-grid-column-menu-header{top:0;border-bottom:1px solid var(--mtx-grid-column-menu-divider-color, var(--mat-sys-outline-variant))}.mtx-grid-column-menu-footer{bottom:0;border-top:1px solid var(--mtx-grid-column-menu-divider-color, var(--mat-sys-outline-variant))}.mtx-grid-column-menu-list{display:block;max-width:100%}.mtx-grid-column-menu-list.cdk-drop-list-dragging .mtx-grid-column-menu-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}.mtx-grid-column-menu-item{display:flex;flex-direction:row;align-items:center}.mtx-grid-column-menu-item.cdk-drag-disabled .cdk-drag-handle{opacity:.35;cursor:no-drop}.mtx-grid-column-menu-item .cdk-drag-handle{cursor:move}.mtx-grid-column-menu-item.cdk-drag-preview{border-radius:4px;box-shadow:0 0 0 1px var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}.mtx-grid-column-menu-item.cdk-drag-placeholder{opacity:0}.mtx-grid-column-menu-item.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.mtx-grid-column-pin-button.mat-mdc-icon-button .mat-mdc-button-touch-target{width:100%;height:100%}.mtx-grid-column-pin-option.mat-menu-item{display:flex;align-items:center;height:32px}.mtx-grid-column-pin-option-placeholder{display:inline-block;width:20px;height:20px;line-height:20px;vertical-align:middle}.mtx-grid-column-pin-option-text{padding:0 8px;vertical-align:middle}.mtx-grid-column-drag-handle-icon:hover{cursor:move}.mtx-grid-column-menu-item-label.mat-mdc-checkbox .mat-mdc-checkbox-touch-target{width:100%;height:100%}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var MtxGridColumnMenu = _MtxGridColumnMenu;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridColumnMenu, [{
    type: Component,
    args: [{
      selector: "mtx-grid-column-menu",
      exportAs: "mtxGridColumnMenu",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [AsyncPipe, NgTemplateOutlet, FormsModule, MatButton, MatIconButton, MatIcon, MatMenu, MatMenuTrigger, MatMenuItem, MatCheckbox, CdkDrag, CdkDropList, MtxToObservablePipe],
      template: `@if (buttonType === 'icon') {
  <button
    [class]="buttonClass"
    matIconButton
    type="button"
    [color]="buttonColor"
    [matMenuTriggerFor]="menu"
  >
    <mat-icon *ngTemplateOutlet="iconTpl"></mat-icon>
  </button>
} @else {
  <button
    [class]="buttonClass"
    [matButton]="buttonType"
    type="button"
    [color]="buttonColor"
    [matMenuTriggerFor]="menu"
  >
    <mat-icon *ngTemplateOutlet="iconTpl"></mat-icon>
    {{ buttonText }}
  </button>
}

<ng-template #iconTpl>
  @if (buttonIcon) {
    <mat-icon>{{buttonIcon}}</mat-icon>
  } @else if(buttonFontIcon) {
    <mat-icon [fontIcon]="buttonFontIcon"></mat-icon>
  } @else if(buttonSvgIcon) {
    <mat-icon [svgIcon]="buttonSvgIcon"></mat-icon>
  }
</ng-template>

<mat-menu #menu="matMenu" class="mtx-grid-column-menu">
  <!-- eslint-disable-next-line @angular-eslint/template/interactive-supports-focus -->
  <div class="mtx-grid-column-menu-content"
    (click)="$event.stopPropagation()" (keydown)="$event.stopPropagation()">
    @if (showHeader) {
      <div class="mtx-grid-column-menu-header">
        @if (headerTemplate) {
          <ng-template [ngTemplateOutlet]="headerTemplate"></ng-template>
        } @else {
          {{headerText}}
        }
      </div>
    }

    <div class="mtx-grid-column-menu-body">
      @if (sortable) {
        <div class="mtx-grid-column-menu-list"
          cdkDropList (cdkDropListDropped)="_handleDroped($event)">
          @for (col of columns; track col.field) {
            <div class="mtx-grid-column-menu-item"
              cdkDrag [cdkDragDisabled]="selectableChecked === 'show'? !col.show : col.hide">
              <svg class="mtx-grid-icon mtx-grid-column-drag-handle-icon" viewBox="0 0 24 24"
                width="24px" height="24px" fill="currentColor" focusable="false">
                <path d="M7,19V17H9V19H7M11,19V17H13V19H11M15,19V17H17V19H15M7,15V13H9V15H7M11,15V13H13V15H11M15,15V13H17V15H15M7,11V9H9V11H7M11,11V9H13V11H11M15,11V9H17V11H15M7,7V5H9V7H7M11,7V5H13V7H11M15,7V5H17V7H15Z" />
              </svg>
              <ng-template [ngTemplateOutlet]="checkboxList"
                [ngTemplateOutletContext]="{ $implicit: col }">
              </ng-template>
            </div>
          }
        </div>
      }

      @if (!sortable) {
        <div class="mtx-grid-column-menu-list">
          @for (col of columns; track col.field) {
            <div class="mtx-grid-column-menu-item">
              <ng-template [ngTemplateOutlet]="checkboxList"
                [ngTemplateOutletContext]="{ $implicit: col }">
              </ng-template>
            </div>
          }
        </div>
      }
    </div>

    @if (showFooter) {
      <div class="mtx-grid-column-menu-footer">
        @if (footerTemplate) {
          <ng-template [ngTemplateOutlet]="footerTemplate"></ng-template>
        } @else {
          {{footerText}}
        }
      </div>
    }
  </div>
</mat-menu>

<ng-template #checkboxList let-col>
  @if (pinnable) {
    <button class="mtx-grid-column-pin-button" mat-icon-button type="button"
      [matMenuTriggerFor]="pinList">
      @if (col.pinned) {
        <svg class="mtx-grid-icon mtx-grid-column-pin-icon"
          viewBox="0 0 24 24" width="24px" height="24px" fill="currentColor" focusable="false">
          <path d="M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z" />
        </svg>
      }
      @if (!col.pinned) {
        <svg class="mtx-grid-icon mtx-grid-column-pin-off-icon"
          viewBox="0 0 24 24" width="24px" height="24px" fill="currentColor" focusable="false">
          <path d="M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z" />
        </svg>
      }
      </button>
      <mat-menu #pinList="matMenu" class="mtx-grid-column-pin-list">
        @for (item of pinOptions; track item) {
          <button class="mtx-grid-column-pin-option" type="button"
            mat-menu-item
            (click)="_handlePinSelect(col, item.value)">
            <span class="mtx-grid-column-pin-option-placeholder">
              <!-- eslint-disable-next-line @angular-eslint/template/eqeqeq -->
              @if (col.pinned==item.value) {
                <svg class="mtx-grid-icon mtx-grid-column-pin-check-icon"
                  viewBox="0 0 24 24" width="24px" height="24px" fill="currentColor" focusable="false">
                  <path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" />
                </svg>
              }
            </span>
            <span class="mtx-grid-column-pin-option-text">{{item.label | toObservable | async}}</span>
          </button>
        }
      </mat-menu>
  }

  @if (selectable) {
    <mat-checkbox class="mtx-grid-column-menu-item-label"
      [(ngModel)]="col[selectableChecked]" [disabled]="col.disabled"
      (change)="_handleChecked(col)">{{col.header | toObservable | async}}</mat-checkbox>
  } @else {
    <span class="mtx-grid-column-menu-item-label">{{col.header | toObservable | async}}</span>
  }
</ng-template>
`,
      styles: [".mtx-grid-column-menu,.mtx-grid-column-pin-list{color:var(--mtx-grid-column-menu-text-color, var(--mat-sys-on-surface-variant))}.mtx-grid-column-menu .mat-mdc-menu-content{padding:0}.mtx-grid-column-menu-body{max-height:65vh;padding:8px 16px;overflow:auto}.mtx-grid-column-menu-header,.mtx-grid-column-menu-footer{position:sticky;z-index:1;padding:8px 16px}.mtx-grid-column-menu-header{top:0;border-bottom:1px solid var(--mtx-grid-column-menu-divider-color, var(--mat-sys-outline-variant))}.mtx-grid-column-menu-footer{bottom:0;border-top:1px solid var(--mtx-grid-column-menu-divider-color, var(--mat-sys-outline-variant))}.mtx-grid-column-menu-list{display:block;max-width:100%}.mtx-grid-column-menu-list.cdk-drop-list-dragging .mtx-grid-column-menu-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}.mtx-grid-column-menu-item{display:flex;flex-direction:row;align-items:center}.mtx-grid-column-menu-item.cdk-drag-disabled .cdk-drag-handle{opacity:.35;cursor:no-drop}.mtx-grid-column-menu-item .cdk-drag-handle{cursor:move}.mtx-grid-column-menu-item.cdk-drag-preview{border-radius:4px;box-shadow:0 0 0 1px var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}.mtx-grid-column-menu-item.cdk-drag-placeholder{opacity:0}.mtx-grid-column-menu-item.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.mtx-grid-column-pin-button.mat-mdc-icon-button .mat-mdc-button-touch-target{width:100%;height:100%}.mtx-grid-column-pin-option.mat-menu-item{display:flex;align-items:center;height:32px}.mtx-grid-column-pin-option-placeholder{display:inline-block;width:20px;height:20px;line-height:20px;vertical-align:middle}.mtx-grid-column-pin-option-text{padding:0 8px;vertical-align:middle}.mtx-grid-column-drag-handle-icon:hover{cursor:move}.mtx-grid-column-menu-item-label.mat-mdc-checkbox .mat-mdc-checkbox-touch-target{width:100%;height:100%}\n"]
    }]
  }], null, {
    menuPanel: [{
      type: ViewChild,
      args: [MatMenu, {
        static: true
      }]
    }],
    menuTrigger: [{
      type: ViewChild,
      args: [MatMenuTrigger]
    }],
    columns: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    selectableChecked: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    pinnable: [{
      type: Input
    }],
    buttonText: [{
      type: Input
    }],
    buttonType: [{
      type: Input
    }],
    buttonColor: [{
      type: Input
    }],
    buttonClass: [{
      type: Input
    }],
    buttonIcon: [{
      type: Input
    }],
    buttonFontIcon: [{
      type: Input
    }],
    buttonSvgIcon: [{
      type: Input
    }],
    showHeader: [{
      type: Input
    }],
    headerText: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    footerText: [{
      type: Input
    }],
    footerTemplate: [{
      type: Input
    }],
    columnChange: [{
      type: Output
    }],
    pinOptions: [{
      type: Input
    }]
  });
})();
var _MtxGridExpansionToggle = class _MtxGridExpansionToggle {
  constructor() {
    this._opened = false;
    this.openedChange = new EventEmitter();
    this.toggleChange = new EventEmitter();
  }
  get opened() {
    return this._opened;
  }
  set opened(newValue) {
    this._opened = newValue;
    this.openedChange.emit(newValue);
  }
  set expandableRow(value) {
    if (value !== this._row) {
      this._row = value;
    }
  }
  set template(value) {
    if (value !== this._tplRef) {
      this._tplRef = value;
    }
  }
  onClick(event) {
    event.preventDefault();
    event.stopPropagation();
    this.toggle();
  }
  toggle() {
    this.opened = !this.opened;
    this.toggleChange.emit(this);
  }
};
_MtxGridExpansionToggle.ɵfac = function MtxGridExpansionToggle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridExpansionToggle)();
};
_MtxGridExpansionToggle.ɵdir = ɵɵdefineDirective({
  type: _MtxGridExpansionToggle,
  selectors: [["", "mtx-grid-expansion-toggle", ""]],
  hostVars: 2,
  hostBindings: function MtxGridExpansionToggle_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function MtxGridExpansionToggle_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("expanded", ctx.opened);
    }
  },
  inputs: {
    opened: "opened",
    expandableRow: "expandableRow",
    template: [0, "expansionRowTpl", "template"]
  },
  outputs: {
    openedChange: "openedChange",
    toggleChange: "toggleChange"
  }
});
var MtxGridExpansionToggle = _MtxGridExpansionToggle;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridExpansionToggle, [{
    type: Directive,
    args: [{
      selector: "[mtx-grid-expansion-toggle]",
      host: {
        "[class.expanded]": "opened",
        "(click)": "onClick($event)"
      }
    }]
  }], null, {
    opened: [{
      type: Input
    }],
    openedChange: [{
      type: Output
    }],
    expandableRow: [{
      type: Input
    }],
    template: [{
      type: Input,
      args: ["expansionRowTpl"]
    }],
    toggleChange: [{
      type: Output
    }]
  });
})();
var _MtxGridSelectableCell = class _MtxGridSelectableCell {
  constructor() {
    this.ctrlKeyPressed = false;
    this.shiftKeyPressed = false;
    this._selected = false;
    this.cellSelectable = true;
    this.cellSelectedChange = new EventEmitter();
  }
  get selected() {
    return this._selected;
  }
  onClick(event) {
    this.ctrlKeyPressed = event.ctrlKey;
    this.shiftKeyPressed = event.shiftKey;
    if (this.cellSelectable) {
      this.select();
    }
  }
  select() {
    this._selected = true;
    this.cellSelectedChange.emit(this);
  }
  deselect() {
    this._selected = false;
    this.cellSelectedChange.emit(this);
  }
  toggle() {
    this._selected = !this._selected;
    this.cellSelectedChange.emit(this);
  }
};
_MtxGridSelectableCell.ɵfac = function MtxGridSelectableCell_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridSelectableCell)();
};
_MtxGridSelectableCell.ɵdir = ɵɵdefineDirective({
  type: _MtxGridSelectableCell,
  selectors: [["", "mtx-grid-selectable-cell", ""]],
  hostVars: 2,
  hostBindings: function MtxGridSelectableCell_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function MtxGridSelectableCell_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("selected", ctx.selected);
    }
  },
  inputs: {
    cellSelectable: "cellSelectable"
  },
  outputs: {
    cellSelectedChange: "cellSelectedChange"
  }
});
var MtxGridSelectableCell = _MtxGridSelectableCell;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridSelectableCell, [{
    type: Directive,
    args: [{
      selector: "[mtx-grid-selectable-cell]",
      host: {
        "[class.selected]": "selected",
        "(click)": "onClick($event)"
      }
    }]
  }], null, {
    cellSelectable: [{
      type: Input
    }],
    cellSelectedChange: [{
      type: Output
    }]
  });
})();
var MTX_GRID_DEFAULT_OPTIONS = new InjectionToken("mtx-grid-default-options");
var _MtxGrid = class _MtxGrid {
  constructor() {
    this._animationsDisabled = inject(ANIMATION_MODULE_TYPE, {
      optional: true
    }) === "NoopAnimations";
    this._utils = inject(MtxGridUtils);
    this._changeDetectorRef = inject(ChangeDetectorRef);
    this._defaultOptions = inject(MTX_GRID_DEFAULT_OPTIONS, {
      optional: true
    });
    this.dataSource = new MatTableDataSource();
    this.displayedColumns = [];
    this.columns = [];
    this.data = [];
    this.length = 0;
    this.loading = false;
    this.columnResizable = this._defaultOptions?.columnResizable ?? false;
    this.emptyValuePlaceholder = this._defaultOptions?.emptyValuePlaceholder ?? "--";
    this.pageOnFront = this._defaultOptions?.pageOnFront ?? true;
    this.showPaginator = this._defaultOptions?.showPaginator ?? true;
    this.pageDisabled = this._defaultOptions?.pageDisabled ?? false;
    this.showFirstLastButtons = this._defaultOptions?.showFirstLastButtons ?? true;
    this.pageIndex = this._defaultOptions?.pageIndex ?? 0;
    this.pageSize = this._defaultOptions?.pageSize ?? 10;
    this.pageSizeOptions = this._defaultOptions?.pageSizeOptions ?? [10, 50, 100];
    this.hidePageSize = this._defaultOptions?.hidePageSize ?? false;
    this.page = new EventEmitter();
    this.sortOnFront = this._defaultOptions?.sortOnFront ?? true;
    this.sortActive = this._defaultOptions?.sortActive ?? "";
    this.sortDirection = this._defaultOptions?.sortDirection ?? "";
    this.sortDisableClear = this._defaultOptions?.sortDisableClear ?? false;
    this.sortDisabled = this._defaultOptions?.sortDisabled ?? false;
    this.sortStart = this._defaultOptions?.sortStart ?? "asc";
    this.sortChange = new EventEmitter();
    this.rowHover = this._defaultOptions?.rowHover ?? false;
    this.rowStriped = this._defaultOptions?.rowStriped ?? false;
    this.rowClick = new EventEmitter();
    this.rowContextMenu = new EventEmitter();
    this.expansionRowStates = [];
    this.expandable = false;
    this.expansionChange = new EventEmitter();
    this.rowSelection = new SelectionModel(true, []);
    this.multiSelectable = this._defaultOptions?.multiSelectable ?? true;
    this.multiSelectionWithClick = this._defaultOptions?.multiSelectionWithClick ?? false;
    this.rowSelectable = this._defaultOptions?.rowSelectable ?? false;
    this.hideRowSelectionCheckbox = this._defaultOptions?.hideRowSelectionCheckbox ?? false;
    this.disableRowClickSelection = this._defaultOptions?.disableRowClickSelection ?? false;
    this.rowSelectionFormatter = {};
    this.rowSelected = [];
    this.rowSelectedChange = new EventEmitter();
    this.cellSelection = [];
    this.cellSelectable = this._defaultOptions?.cellSelectable ?? true;
    this.cellSelectedChange = new EventEmitter();
    this.showToolbar = this._defaultOptions?.showToolbar ?? false;
    this.toolbarTitle = this._defaultOptions?.toolbarTitle ?? "";
    this.columnHideable = this._defaultOptions?.columnHideable ?? true;
    this.columnHideableChecked = this._defaultOptions?.columnHideableChecked ?? "show";
    this.columnSortable = this._defaultOptions?.columnSortable ?? true;
    this.columnPinnable = this._defaultOptions?.columnPinnable ?? true;
    this.columnChange = new EventEmitter();
    this.columnPinOptions = this._defaultOptions?.columnPinOptions ?? [];
    this.showColumnMenuButton = this._defaultOptions?.showColumnMenuButton ?? true;
    this.columnMenuButtonText = this._defaultOptions?.columnMenuButtonText ?? "";
    this.columnMenuButtonType = this._defaultOptions?.columnMenuButtonType ?? "outlined";
    this.columnMenuButtonColor = this._defaultOptions?.columnMenuButtonColor;
    this.columnMenuButtonClass = this._defaultOptions?.columnMenuButtonClass ?? "";
    this.columnMenuButtonIcon = this._defaultOptions?.columnMenuButtonIcon ?? "";
    this.columnMenuButtonFontIcon = this._defaultOptions?.columnMenuButtonFontIcon ?? "";
    this.columnMenuButtonSvgIcon = this._defaultOptions?.columnMenuButtonSvgIcon ?? "";
    this.showColumnMenuHeader = this._defaultOptions?.showColumnMenuHeader ?? false;
    this.columnMenuHeaderText = this._defaultOptions?.columnMenuHeaderText ?? "Columns Header";
    this.showColumnMenuFooter = this._defaultOptions?.showColumnMenuFooter ?? false;
    this.columnMenuFooterText = this._defaultOptions?.columnMenuFooterText ?? "Columns Footer";
    this.noResultText = this._defaultOptions?.noResultText ?? "No records found";
    this.useContentRowTemplate = false;
    this.useContentHeaderRowTemplate = false;
    this.useContentFooterRowTemplate = false;
    this.showSummary = false;
    this.showSidebar = false;
    this.showStatusbar = false;
  }
  get _hasNoResult() {
    return (!this.dataSource.data || this.dataSource.data.length === 0) && !this.loading;
  }
  // TODO: Summary display conditions
  get _whetherShowSummary() {
    return this.showSummary;
  }
  detectChanges() {
    this._changeDetectorRef.detectChanges();
  }
  _getColData(data, colDef) {
    return this._utils.getColData(data, colDef);
  }
  _isColumnHide(item) {
    return item.hide !== void 0 ? item.hide : item.show !== void 0 ? !item.show : false;
  }
  // Waiting for async data
  ngOnChanges(changes) {
    this._countPinnedPosition();
    this.displayedColumns = this.columns.filter((item) => !this._isColumnHide(item)).map((item) => item.field);
    if (this.showColumnMenuButton) {
      this.columns.forEach((item) => {
        item.hide = this._isColumnHide(item);
        item.show = !item.hide;
      });
    }
    if (this.rowSelectable && !this.hideRowSelectionCheckbox) {
      this.displayedColumns.unshift("MtxGridCheckboxColumnDef");
    }
    if (this.expandable) {
      this.expansionRowStates = [];
      this.data?.forEach((_) => {
        this.expansionRowStates.push({
          expanded: false
        });
      });
    }
    if (this.rowSelectable) {
      this.rowSelection = new SelectionModel(this.multiSelectable, this.rowSelected);
    }
    this.dataSource = new MatTableDataSource(this.data);
    this.dataSource.paginator = this.pageOnFront ? this.paginator : null;
    this.dataSource.sort = this.sortOnFront ? this.sort : null;
    if (changes.data) {
      this.scrollTop(0);
    }
  }
  ngAfterViewInit() {
    if (this.pageOnFront) {
      this.dataSource.paginator = this.paginator;
    }
    if (this.sortOnFront) {
      this.dataSource.sort = this.sort;
    }
    if (this.rowDefs?.length > 0 && this.useContentRowTemplate) {
      this.rowDefs.forEach((rowDef) => this.table.addRowDef(rowDef));
    }
    if (this.headerRowDefs?.length > 0 && this.useContentHeaderRowTemplate) {
      this.headerRowDefs.forEach((headerRowDef) => this.table.addHeaderRowDef(headerRowDef));
    }
    if (this.footerRowDefs?.length > 0 && this.useContentFooterRowTemplate) {
      this.footerRowDefs.forEach((footerRowDef) => this.table.addFooterRowDef(footerRowDef));
    }
  }
  ngOnDestroy() {
  }
  _countPinnedPosition() {
    const count = (acc, cur) => acc + parseFloat(cur.width || "80px");
    const pinnedLeftCols = this.columns.filter((col) => col.pinned && col.pinned === "left");
    pinnedLeftCols.forEach((item, idx) => {
      item.left = pinnedLeftCols.slice(0, idx).reduce(count, 0) + "px";
    });
    const pinnedRightCols = this.columns.filter((col) => col.pinned && col.pinned === "right").reverse();
    pinnedRightCols.forEach((item, idx) => {
      item.right = pinnedRightCols.slice(0, idx).reduce(count, 0) + "px";
    });
  }
  _getIndex(index, dataIndex) {
    return index === void 0 ? dataIndex : index;
  }
  _onSortChange(sort) {
    this.sortChange.emit(sort);
  }
  _onRowDataChange(record) {
    this.rowChangeRecord = record;
    this._changeDetectorRef.markForCheck();
  }
  /** Expansion change event */
  _onExpansionChange(expansionRef, rowData, column, index) {
    this.expansionChange.emit({
      expanded: expansionRef.opened,
      data: rowData,
      index,
      column
    });
  }
  /** Cell select event */
  _selectCell(cellRef, rowData, colDef) {
    if (this._selectedCell !== cellRef) {
      const colValue = this._utils.getCellValue(rowData, colDef);
      this.cellSelection = [];
      this.cellSelection.push({
        cellData: colValue,
        rowData,
        colDef
      });
      this.cellSelectedChange.emit(this.cellSelection);
      if (this._selectedCell) {
        this._selectedCell.deselect();
      }
    }
    this._selectedCell = cellRef.selected ? cellRef : void 0;
  }
  /** Row select event */
  _selectRow(event, rowData, index) {
    if (this.rowSelectable && !this.rowSelectionFormatter.disabled?.(rowData, index) && !this.rowSelectionFormatter.hideCheckbox?.(rowData, index) && !this.disableRowClickSelection) {
      if (!this.multiSelectionWithClick && !event.ctrlKey && !event.metaKey) {
        this.rowSelection.clear();
      }
      this._toggleNormalCheckbox(rowData);
    }
    this.rowClick.emit({
      event,
      rowData,
      index
    });
  }
  /** Whether the number of selected elements matches the total number of rows. */
  _isAllSelected() {
    const numSelected = this.rowSelection.selected.length;
    const numRows = this.dataSource.data.filter((row, index) => !this.rowSelectionFormatter.disabled?.(row, index)).length;
    return numSelected === numRows;
  }
  /** Select all rows if they are not all selected; otherwise clear selection. */
  _toggleMasterCheckbox() {
    this._isAllSelected() ? this.rowSelection.clear() : this.dataSource.data.forEach((row, index) => {
      if (!this.rowSelectionFormatter.disabled?.(row, index)) {
        this.rowSelection.select(row);
      }
    });
    this.rowSelectedChange.emit(this.rowSelection.selected);
  }
  /** Select normal row */
  _toggleNormalCheckbox(row) {
    this.rowSelection.toggle(row);
    this.rowSelectedChange.emit(this.rowSelection.selected);
  }
  /** Column change event */
  _onColumnChange(columns) {
    this.columnChange.emit(columns);
    this.displayedColumns = Object.assign([], this.getDisplayedColumnFields(columns));
    if (this.rowSelectable && !this.hideRowSelectionCheckbox) {
      this.displayedColumns.unshift("MtxGridCheckboxColumnDef");
    }
  }
  getDisplayedColumnFields(columns) {
    const fields = columns.filter((item) => this.columnHideableChecked === "show" ? item.show : !item.hide).map((item) => item.field);
    return fields;
  }
  /** Customize expansion event */
  toggleExpansion(index) {
    if (!this.expandable) {
      throw new Error("The `expandable` should be set true.");
    }
    this.expansionRowStates[index].expanded = !this.expansionRowStates[index].expanded;
    return this.expansionRowStates[index].expanded;
  }
  /** Scroll to top when turn to the next page. */
  _onPage(e) {
    if (this.pageOnFront) {
      this.scrollTop(0);
    }
    this.page.emit(e);
  }
  scrollTop(value) {
    if (value == null) {
      return this.tableContainer?.nativeElement.scrollTop;
    }
    if (this.tableContainer && !this.loading) {
      this.tableContainer.nativeElement.scrollTop = value;
    }
  }
  scrollLeft(value) {
    if (value == null) {
      return this.tableContainer?.nativeElement.scrollLeft;
    }
    if (this.tableContainer && !this.loading) {
      this.tableContainer.nativeElement.scrollLeft = value;
    }
  }
  _contextmenu(event, rowData, index) {
    this.rowContextMenu.emit({
      event,
      rowData,
      index
    });
  }
};
_MtxGrid.ɵfac = function MtxGrid_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGrid)();
};
_MtxGrid.ɵcmp = ɵɵdefineComponent({
  type: _MtxGrid,
  selectors: [["mtx-grid"]],
  contentQueries: function MtxGrid_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatRowDef, 4);
      ɵɵcontentQuery(dirIndex, MatHeaderRowDef, 4);
      ɵɵcontentQuery(dirIndex, MatFooterRow, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.rowDefs = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerRowDefs = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerRowDefs = _t);
    }
  },
  viewQuery: function MtxGrid_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(MatTable, 5);
      ɵɵviewQuery(MatPaginator, 5);
      ɵɵviewQuery(MatSort, 5);
      ɵɵviewQuery(ColumnResize, 5);
      ɵɵviewQuery(MtxGridColumnMenu, 5);
      ɵɵviewQuery(_c4, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.table = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.paginator = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sort = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnResize = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenu = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableContainer = _t.first);
    }
  },
  hostAttrs: [1, "mtx-grid"],
  hostVars: 2,
  hostBindings: function MtxGrid_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("mtx-grid-animations-enabled", !ctx._animationsDisabled);
    }
  },
  inputs: {
    displayedColumns: "displayedColumns",
    columns: "columns",
    data: "data",
    length: "length",
    loading: [2, "loading", "loading", booleanAttribute],
    trackBy: "trackBy",
    columnResizable: [2, "columnResizable", "columnResizable", booleanAttribute],
    emptyValuePlaceholder: "emptyValuePlaceholder",
    pageOnFront: [2, "pageOnFront", "pageOnFront", booleanAttribute],
    showPaginator: [2, "showPaginator", "showPaginator", booleanAttribute],
    pageDisabled: [2, "pageDisabled", "pageDisabled", booleanAttribute],
    showFirstLastButtons: [2, "showFirstLastButtons", "showFirstLastButtons", booleanAttribute],
    pageIndex: "pageIndex",
    pageSize: "pageSize",
    pageSizeOptions: "pageSizeOptions",
    hidePageSize: [2, "hidePageSize", "hidePageSize", booleanAttribute],
    paginationTemplate: "paginationTemplate",
    sortOnFront: [2, "sortOnFront", "sortOnFront", booleanAttribute],
    sortActive: "sortActive",
    sortDirection: "sortDirection",
    sortDisableClear: [2, "sortDisableClear", "sortDisableClear", booleanAttribute],
    sortDisabled: [2, "sortDisabled", "sortDisabled", booleanAttribute],
    sortStart: "sortStart",
    rowHover: [2, "rowHover", "rowHover", booleanAttribute],
    rowStriped: [2, "rowStriped", "rowStriped", booleanAttribute],
    expandable: [2, "expandable", "expandable", booleanAttribute],
    expansionTemplate: "expansionTemplate",
    multiSelectable: [2, "multiSelectable", "multiSelectable", booleanAttribute],
    multiSelectionWithClick: [2, "multiSelectionWithClick", "multiSelectionWithClick", booleanAttribute],
    rowSelectable: [2, "rowSelectable", "rowSelectable", booleanAttribute],
    hideRowSelectionCheckbox: [2, "hideRowSelectionCheckbox", "hideRowSelectionCheckbox", booleanAttribute],
    disableRowClickSelection: [2, "disableRowClickSelection", "disableRowClickSelection", booleanAttribute],
    rowSelectionFormatter: "rowSelectionFormatter",
    rowClassFormatter: "rowClassFormatter",
    rowSelected: "rowSelected",
    cellSelectable: [2, "cellSelectable", "cellSelectable", booleanAttribute],
    showToolbar: [2, "showToolbar", "showToolbar", booleanAttribute],
    toolbarTitle: "toolbarTitle",
    toolbarTemplate: "toolbarTemplate",
    columnHideable: [2, "columnHideable", "columnHideable", booleanAttribute],
    columnHideableChecked: "columnHideableChecked",
    columnSortable: [2, "columnSortable", "columnSortable", booleanAttribute],
    columnPinnable: [2, "columnPinnable", "columnPinnable", booleanAttribute],
    columnPinOptions: "columnPinOptions",
    showColumnMenuButton: [2, "showColumnMenuButton", "showColumnMenuButton", booleanAttribute],
    columnMenuButtonText: "columnMenuButtonText",
    columnMenuButtonType: "columnMenuButtonType",
    columnMenuButtonColor: "columnMenuButtonColor",
    columnMenuButtonClass: "columnMenuButtonClass",
    columnMenuButtonIcon: "columnMenuButtonIcon",
    columnMenuButtonFontIcon: "columnMenuButtonFontIcon",
    columnMenuButtonSvgIcon: "columnMenuButtonSvgIcon",
    showColumnMenuHeader: [2, "showColumnMenuHeader", "showColumnMenuHeader", booleanAttribute],
    columnMenuHeaderText: "columnMenuHeaderText",
    columnMenuHeaderTemplate: "columnMenuHeaderTemplate",
    showColumnMenuFooter: [2, "showColumnMenuFooter", "showColumnMenuFooter", booleanAttribute],
    columnMenuFooterText: "columnMenuFooterText",
    columnMenuFooterTemplate: "columnMenuFooterTemplate",
    noResultText: "noResultText",
    noResultTemplate: "noResultTemplate",
    headerTemplate: "headerTemplate",
    headerExtraTemplate: "headerExtraTemplate",
    cellTemplate: "cellTemplate",
    useContentRowTemplate: [2, "useContentRowTemplate", "useContentRowTemplate", booleanAttribute],
    useContentHeaderRowTemplate: [2, "useContentHeaderRowTemplate", "useContentHeaderRowTemplate", booleanAttribute],
    useContentFooterRowTemplate: [2, "useContentFooterRowTemplate", "useContentFooterRowTemplate", booleanAttribute],
    showSummary: [2, "showSummary", "showSummary", booleanAttribute],
    summaryTemplate: "summaryTemplate",
    showSidebar: [2, "showSidebar", "showSidebar", booleanAttribute],
    sidebarTemplate: "sidebarTemplate",
    showStatusbar: [2, "showStatusbar", "showStatusbar", booleanAttribute],
    statusbarTemplate: "statusbarTemplate"
  },
  outputs: {
    page: "page",
    sortChange: "sortChange",
    rowClick: "rowClick",
    rowContextMenu: "rowContextMenu",
    expansionChange: "expansionChange",
    rowSelectedChange: "rowSelectedChange",
    cellSelectedChange: "cellSelectedChange",
    columnChange: "columnChange"
  },
  exportAs: ["mtxGrid"],
  features: [ɵɵNgOnChangesFeature],
  decls: 17,
  vars: 9,
  consts: [["tableContainer", ""], ["headerExtraTplBase", ""], [1, "mtx-grid-progress"], [1, "mtx-grid-toolbar"], [1, "mtx-grid-main", "mtx-grid-layout"], [1, "mtx-grid-content", "mtx-grid-layout"], [1, "mat-table-container"], ["mat-table", "", "matSort", "", 3, "mat-table-hover", "mat-table-striped", "mat-table-expandable", "dataSource", "multiTemplateDataRows", "matSortActive", "matSortDirection", "matSortDisableClear", "matSortDisabled", "matSortStart", "trackBy"], ["mat-table", "", "columnResize", "", "matSort", "", 3, "mat-table-hover", "mat-table-striped", "mat-table-expandable", "dataSource", "multiTemplateDataRows", "matSortActive", "matSortDirection", "matSortDisableClear", "matSortDisabled", "matSortStart", "trackBy"], [1, "mtx-grid-no-result"], [1, "mtx-grid-sidebar"], [1, "mtx-grid-footer"], [1, "mtx-grid-statusbar"], [1, "mtx-grid-pagination"], [3, "ngTemplateOutlet"], [3, "mat-paginator-hidden", "showFirstLastButtons", "length", "pageIndex", "pageSize", "pageSizeOptions", "hidePageSize", "disabled"], ["mode", "indeterminate"], [1, "mtx-grid-toolbar-content"], [1, "mtx-grid-toolbar-actions"], [3, "columns", "buttonText", "buttonType", "buttonColor", "buttonClass", "buttonIcon", "buttonFontIcon", "buttonSvgIcon", "selectable", "selectableChecked", "sortable", "pinnable", "showHeader", "headerText", "headerTemplate", "showFooter", "footerText", "footerTemplate", "pinOptions"], [1, "mtx-grid-toolbar-title"], [3, "columnChange", "columns", "buttonText", "buttonType", "buttonColor", "buttonClass", "buttonIcon", "buttonFontIcon", "buttonSvgIcon", "selectable", "selectableChecked", "sortable", "pinnable", "showHeader", "headerText", "headerTemplate", "showFooter", "footerText", "footerTemplate", "pinOptions"], ["mat-table", "", "matSort", "", 3, "matSortChange", "dataSource", "multiTemplateDataRows", "matSortActive", "matSortDirection", "matSortDisableClear", "matSortDisabled", "matSortStart", "trackBy"], ["matColumnDef", "MtxGridCheckboxColumnDef"], [3, "matColumnDef", "sticky", "stickyEnd"], ["mat-header-row", ""], ["mat-row", "", 3, "class", "selected"], ["mat-footer-row", ""], ["mat-header-cell", "", "class", "mtx-grid-checkbox-cell", 4, "matHeaderCellDef"], ["mat-cell", "", "class", "mtx-grid-checkbox-cell", 4, "matCellDef"], ["mat-footer-cell", "", "class", "mtx-grid-checkbox-cell", 4, "matFooterCellDef"], ["mat-header-cell", "", 1, "mtx-grid-checkbox-cell"], [3, "checked", "indeterminate"], [3, "change", "checked", "indeterminate"], ["mat-cell", "", 1, "mtx-grid-checkbox-cell"], [3, "disabled", "checked"], [3, "click", "change", "disabled", "checked"], ["mat-footer-cell", "", 1, "mtx-grid-checkbox-cell"], ["mat-header-cell", "", 3, "class", "mat-table-sticky-left", "mat-table-sticky-right", "width", "min-width", "left", "right", 4, "matHeaderCellDef"], ["mat-cell", "", "mtx-grid-selectable-cell", "", 3, "class", "mat-table-sticky-left", "mat-table-sticky-right", "width", "min-width", "left", "right", "cellSelectable", "cellSelectedChange", 4, "matCellDef"], ["mat-footer-cell", "", 3, "mat-table-sticky-left", "mat-table-sticky-right", "width", "min-width", "left", "right", 4, "matFooterCellDef"], ["mat-header-cell", ""], [1, "mat-header-cell-inner"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "mat-sort-header", "disabled", "disableClear", "arrowPosition", "start"], [1, "mtx-grid-expansion-placeholder"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mat-sort-header-icon"], ["d", "M3,13H15V11H3M3,6V8H21V6M3,18H9V16H3V18Z"], ["mat-cell", "", "mtx-grid-selectable-cell", "", 3, "cellSelectedChange", "cellSelectable"], ["mat-icon-button", "", "mtx-grid-expansion-toggle", "", "type", "button", 1, "mtx-grid-row-expand-button", 3, "opened"], [3, "rowDataChange", "rowData", "colDef", "placeholder"], ["mat-icon-button", "", "mtx-grid-expansion-toggle", "", "type", "button", 1, "mtx-grid-row-expand-button", 3, "openedChange", "toggleChange", "opened"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mtx-grid-icon", "mtx-grid-row-expand-icon"], ["d", "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"], ["mat-footer-cell", ""], [3, "summary", "data", "colDef", "placeholder"], ["mat-header-row", "", 4, "matHeaderRowDef", "matHeaderRowDefSticky"], ["mat-row", "", 3, "class", "selected", "click", "contextmenu", 4, "matRowDef", "matRowDefColumns"], ["mat-row", "", 3, "click", "contextmenu"], ["mat-footer-row", "", 4, "matFooterRowDef", "matFooterRowDefSticky"], ["matColumnDef", "MtxGridExpansionColumnDef"], ["mat-cell", "", 4, "matCellDef"], ["mat-row", "", "class", "mtx-grid-expansion", 3, "class", 4, "matRowDef", "matRowDefColumns"], ["mat-cell", ""], [1, "mtx-grid-expansion-detail-wrapper"], [1, "mtx-grid-expansion-detail"], ["mat-row", "", 1, "mtx-grid-expansion"], ["mat-table", "", "columnResize", "", "matSort", "", 3, "matSortChange", "dataSource", "multiTemplateDataRows", "matSortActive", "matSortDirection", "matSortDisableClear", "matSortDisabled", "matSortStart", "trackBy"], ["mat-header-cell", "", 3, "class", "mat-table-sticky-left", "mat-table-sticky-right", "width", "left", "right", "resizable", "matResizableMinWidthPx", "matResizableMaxWidthPx", 4, "matHeaderCellDef"], ["mat-cell", "", "mtx-grid-selectable-cell", "", 3, "class", "mat-table-sticky-left", "mat-table-sticky-right", "width", "left", "right", "cellSelectable", "cellSelectedChange", 4, "matCellDef"], ["mat-footer-cell", "", 3, "mat-table-sticky-left", "mat-table-sticky-right", "width", "left", "right", 4, "matFooterCellDef"], ["mat-header-cell", "", 3, "resizable", "matResizableMinWidthPx", "matResizableMaxWidthPx"], [3, "page", "showFirstLastButtons", "length", "pageIndex", "pageSize", "pageSizeOptions", "hidePageSize", "disabled"]],
  template: function MtxGrid_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵconditionalCreate(0, MtxGrid_Conditional_0_Template, 2, 0, "div", 2);
      ɵɵconditionalCreate(1, MtxGrid_Conditional_1_Template, 6, 2, "div", 3);
      ɵɵelementStart(2, "div", 4)(3, "div", 5)(4, "div", 6, 0);
      ɵɵconditionalCreate(6, MtxGrid_Conditional_6_Template, 8, 19, "table", 7)(7, MtxGrid_Conditional_7_Template, 8, 19, "table", 8);
      ɵɵelementEnd();
      ɵɵconditionalCreate(8, MtxGrid_Conditional_8_Template, 3, 1, "div", 9);
      ɵɵelementEnd();
      ɵɵconditionalCreate(9, MtxGrid_Conditional_9_Template, 2, 1, "div", 10);
      ɵɵelementEnd();
      ɵɵelementStart(10, "div", 11);
      ɵɵconditionalCreate(11, MtxGrid_Conditional_11_Template, 2, 1, "div", 12);
      ɵɵelementStart(12, "div", 13);
      ɵɵconditionalCreate(13, MtxGrid_Conditional_13_Template, 1, 1, null, 14)(14, MtxGrid_Conditional_14_Template, 1, 9, "mat-paginator", 15);
      ɵɵelementEnd()();
      ɵɵtemplate(15, MtxGrid_ng_template_15_Template, 3, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵconditional(ctx.loading ? 0 : -1);
      ɵɵadvance();
      ɵɵconditional(ctx.showToolbar ? 1 : -1);
      ɵɵadvance(3);
      ɵɵclassProp("mat-table-with-data", !ctx._hasNoResult);
      ɵɵadvance(2);
      ɵɵconditional(!ctx.columnResizable ? 6 : 7);
      ɵɵadvance(2);
      ɵɵconditional(ctx._hasNoResult ? 8 : -1);
      ɵɵadvance();
      ɵɵconditional(ctx.showSidebar ? 9 : -1);
      ɵɵadvance(2);
      ɵɵconditional(ctx.showStatusbar ? 11 : -1);
      ɵɵadvance(2);
      ɵɵconditional(ctx.paginationTemplate ? 13 : 14);
    }
  },
  dependencies: [NgTemplateOutlet, MatProgressBar, MatIconButton, MatCheckbox, MatTable, MatColumnDef, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatFooterRowDef, MatFooterRow, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatFooterCellDef, MatFooterCell, MatSort, MatSortHeader, MatPaginator, MatResizable, MatColumnResize, MtxGridCell, MtxGridColumnMenu, MtxGridSelectableCell, MtxGridExpansionToggle, AsyncPipe, MtxIsTemplateRefPipe, MtxGridColClassPipe, MtxGridRowClassPipe, MtxToObservablePipe],
  styles: ['.mat-column-resize-table.cdk-column-resize-with-resized-column{table-layout:fixed}.mat-column-resize-flex .mat-mdc-header-cell,.mat-column-resize-flex .mat-mdc-cell{box-sizing:border-box;min-width:32px}.mat-mdc-header-cell{position:relative}.mat-resizable{box-sizing:border-box}.mat-mdc-header-cell:not(.mat-resizable):after,.mat-resizable-handle{position:absolute;bottom:0;top:0;right:0;width:1px;background:transparent;transition:background .3s cubic-bezier(.55,0,.55,.2)}.mat-mdc-header-cell:not(.mat-resizable):after{content:""}[dir=rtl] .mat-mdc-header-cell:not(.mat-resizable):after,[dir=rtl] .mat-resizable-handle{left:0;right:auto}[dir=rtl] .mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-header-cell,[dir=rtl] .mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-mdc-header-cell{border-left:none}.mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-mdc-header-cell{border-right:none}.mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-mdc-header-cell:not(.mat-resizable):after{background-color:var(--mtx-grid-resizable-handle-disabled-background-color, var(--mat-sys-outline-variant))}.mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-resizable-handle{background-color:var(--mtx-grid-resizable-handle-hover-background-color, var(--mat-sys-primary))}.mat-resizable.cdk-resizable-overlay-thumb-active>.mat-resizable-handle{opacity:0;transition:none}.mat-resizable-handle:focus,.mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-resizable-handle:focus{outline:none;background-color:var(--mtx-grid-resizable-handle-active-background-color, var(--mat-sys-primary))}.mat-column-resize-overlay-thumb{background:transparent;cursor:col-resize;width:100%;height:100%;transition:background .3s cubic-bezier(.55,0,.55,.2);-webkit-user-select:none;user-select:none}.mat-column-resize-overlay-thumb:active{will-change:transform;background:linear-gradient(90deg,transparent,transparent 7px,var(--mtx-grid-resizable-handle-active-background-color, var(--mat-sys-primary)) 7px,var(--mtx-grid-resizable-handle-active-background-color, var(--mat-sys-primary)) 9px,transparent 9px,transparent)}.mat-column-resize-overlay-thumb:active .mat-column-resize-overlay-thumb-top{background:linear-gradient(90deg,transparent,transparent 4px,var(--mtx-grid-resizable-handle-active-background-color, var(--mat-sys-primary)) 4px,var(--mtx-grid-resizable-handle-active-background-color, var(--mat-sys-primary)) 12px,transparent 12px,transparent)}.mat-column-resize-overlay-thumb-top{width:100%}.mtx-grid{position:relative;display:flex;flex-direction:column;width:100%;overflow:hidden;border:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant));border-radius:var(--mtx-grid-container-shape, var(--mat-sys-corner-medium))}.mtx-grid .mat-mdc-table{--mat-table-row-item-outline-color: var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}.mtx-grid .mat-mdc-table.mat-table-striped .mat-row-odd{background-color:var(--mtx-grid-table-row-striped-background-color, var(--mat-sys-surface-container))}.mtx-grid .mat-mdc-table.mat-table-hover .mat-mdc-row:hover{background-color:var(--mtx-grid-table-row-hover-background-color, var(--mat-sys-secondary-container))}.mtx-grid .mat-mdc-table.mat-table-hover .mat-mdc-row.selected:hover{background-color:var(--mtx-grid-table-row-selected-hover-background-color, var(--mat-sys-primary-container))}.mtx-grid .mat-mdc-table .mat-mdc-row.selected{background-color:var(--mtx-grid-table-row-selected-background-color, var(--mat-sys-secondary-container))}.mtx-grid .mat-mdc-table .mat-mdc-cell.selected{box-shadow:inset 0 0 0 1px var(--mtx-grid-table-cell-selected-outline-color, var(--mat-sys-primary))}.mtx-grid .mat-table-container{overflow:auto}.mtx-grid .mat-table-container.mat-table-with-data{flex:1}.mtx-grid .mat-mdc-table:not(.mat-column-resize-table){min-width:100%;border-collapse:separate}.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-header-cell:not(.mtx-grid-checkbox-cell),.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-footer-cell:not(.mtx-grid-checkbox-cell),.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-cell:not(.mtx-grid-checkbox-cell){min-width:var(--mtx-grid-table-cell-min-width, 80px)}.mtx-grid .mat-table-sticky-left{border-right:1px solid var(--mat-table-row-item-outline-color)}[dir=rtl] .mtx-grid .mat-table-sticky-left{border-right-width:0;border-left:1px solid var(--mat-table-row-item-outline-color)}.mtx-grid .mat-table-sticky-right{border-left:1px solid var(--mat-table-row-item-outline-color)}[dir=rtl] .mtx-grid .mat-table-sticky-right{border-left-width:0;border-right:1px solid var(--mat-table-row-item-outline-color)}.mtx-grid .mat-mdc-footer-cell{border-top:1px solid var(--mat-table-row-item-outline-color);background-color:var(--mtx-grid-table-footer-background-color, var(--mat-sys-surface-container))}.mtx-grid .mat-mdc-row.mtx-grid-expansion{height:0;overflow:hidden}.mtx-grid .mat-mdc-row.mtx-grid-expansion .mat-mdc-cell{padding-top:0;padding-bottom:0}.mtx-grid .mat-mdc-row.mtx-grid-expansion.collapsed .mat-mdc-cell{border-bottom-width:0}.mtx-grid .mat-sort-header-icon{margin-left:4px}[dir=rtl] .mtx-grid .mat-sort-header-icon{margin-left:0;margin-right:4px}.mtx-grid .mat-header-cell-inner{display:inline-flex;align-items:center;vertical-align:middle}.mtx-grid .mat-mdc-paginator{border-top:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant));border-bottom-left-radius:var(--mtx-grid-container-shape, var(--mat-sys-corner-medium));border-bottom-right-radius:var(--mtx-grid-container-shape, var(--mat-sys-corner-medium))}.mtx-grid .mat-paginator-hidden{display:none}.mtx-grid .mtx-grid-checkbox-cell{width:60px;min-width:60px;padding:0 calc((60px - var(--mat-checkbox-state-layer-size, 40px)) / 2)}.mtx-grid-progress{position:absolute;top:0;z-index:120;width:100%}.mtx-grid-toolbar{display:flex;justify-content:space-between;align-items:center;min-height:var(--mat-table-header-container-height, 56px);padding:8px;box-sizing:border-box;border-bottom:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}.mtx-grid-toolbar-content{flex:1;width:0;padding:0 8px}.mtx-grid-layout{display:flex;flex:1 1 auto;overflow:auto}.mtx-grid-content{flex-direction:column;width:0}.mtx-grid-sidebar{max-width:50%;border-left:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}[dir=rtl] .mtx-grid-sidebar{border-left-width:0;border-right:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}.mtx-grid-footer{position:relative;z-index:1}.mtx-grid-statusbar{display:flex;align-items:center;min-height:var(--mat-table-header-container-height, 56px);padding:8px;box-sizing:border-box;border-top:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}.mtx-grid-no-result{display:flex;justify-content:center;align-items:center;flex:1;min-height:150px}.mtx-grid-expansion-placeholder{display:inline-block;vertical-align:middle;width:var(--mat-icon-button-state-layer-size, var(--mtx-grid-row-expand-button-size, 40px));height:var(--mat-icon-button-state-layer-size, var(--mtx-grid-row-expand-button-size, 40px))}.mtx-grid-expansion-detail-wrapper{display:grid;grid-template-rows:0fr;grid-template-columns:100%;padding:0;overflow:hidden}.mtx-grid-expansion.expanded .mtx-grid-expansion-detail-wrapper{grid-template-rows:1fr;padding:calc((var(--mat-table-row-item-container-height, 52px) - 20px) / 2) 0}.mtx-grid-expansion-detail{min-height:0}.mtx-grid-animations-enabled .mtx-grid-expansion-detail-wrapper{transition:all 225ms cubic-bezier(.4,0,.2,1)}.mtx-grid-row-expand-button.expanded .mtx-grid-row-expand-icon{transform:rotate(90deg)}.mtx-grid-row-expand-button.mat-mdc-icon-button,.mtx-grid-row-expand-button+mtx-grid-cell{vertical-align:middle}\n'],
  encapsulation: 2,
  changeDetection: 0
});
var MtxGrid = _MtxGrid;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGrid, [{
    type: Component,
    args: [{
      selector: "mtx-grid",
      exportAs: "mtxGrid",
      host: {
        "class": "mtx-grid",
        "[class.mtx-grid-animations-enabled]": "!_animationsDisabled"
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [AsyncPipe, NgTemplateOutlet, MatProgressBar, MatIconButton, MatCheckbox, MatTable, MatColumnDef, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatFooterRowDef, MatFooterRow, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatFooterCellDef, MatFooterCell, MatSort, MatSortHeader, MatPaginator, MatResizable, MatColumnResize, MtxGridCell, MtxGridColumnMenu, MtxGridSelectableCell, MtxGridExpansionToggle, MtxIsTemplateRefPipe, MtxGridColClassPipe, MtxGridRowClassPipe, MtxToObservablePipe],
      template: `<!-- Progress bar-->
@if (loading) {
  <div class="mtx-grid-progress">
    <mat-progress-bar mode="indeterminate"></mat-progress-bar>
  </div>
}

<!-- Toolbar -->
@if (showToolbar) {
  <div class="mtx-grid-toolbar">
    <div class="mtx-grid-toolbar-content">
      @if (toolbarTemplate) {
        <ng-template [ngTemplateOutlet]="toolbarTemplate"></ng-template>
      } @else {
        @if (toolbarTitle) {
          <div class="mtx-grid-toolbar-title">{{toolbarTitle}}</div>
        }
      }
    </div>
    <div class="mtx-grid-toolbar-actions">
      @if (showColumnMenuButton) {
        <mtx-grid-column-menu
          [columns]="columns"
          [buttonText]="columnMenuButtonText"
          [buttonType]="columnMenuButtonType"
          [buttonColor]="columnMenuButtonColor"
          [buttonClass]="columnMenuButtonClass"
          [buttonIcon]="columnMenuButtonIcon"
          [buttonFontIcon]="columnMenuButtonFontIcon"
          [buttonSvgIcon]="columnMenuButtonSvgIcon"
          [selectable]="columnHideable"
          [selectableChecked]="columnHideableChecked"
          [sortable]="columnSortable"
          [pinnable]="columnPinnable"
          [showHeader]="showColumnMenuHeader"
          [headerText]="columnMenuHeaderText"
          [headerTemplate]="columnMenuHeaderTemplate"
          [showFooter]="showColumnMenuFooter"
          [footerText]="columnMenuFooterText"
          [footerTemplate]="columnMenuFooterTemplate"
          [pinOptions]="columnPinOptions"
          (columnChange)="_onColumnChange($event)">
        </mtx-grid-column-menu>
      }
    </div>
  </div>
}

<div class="mtx-grid-main mtx-grid-layout">
  <!-- Table content -->
  <div class="mtx-grid-content mtx-grid-layout">
    <div #tableContainer class="mat-table-container" [class.mat-table-with-data]="!_hasNoResult">
      @if (!columnResizable) {
        <table mat-table
          [class.mat-table-hover]="rowHover"
          [class.mat-table-striped]="rowStriped"
          [class.mat-table-expandable]="expandable"
          [dataSource]="dataSource"
          [multiTemplateDataRows]="expandable"
          matSort
          [matSortActive]="sortActive"
          [matSortDirection]="sortDirection"
          [matSortDisableClear]="sortDisableClear"
          [matSortDisabled]="sortDisabled"
          [matSortStart]="sortStart"
          (matSortChange)="_onSortChange($event)"
          [trackBy]="trackBy">
          @if (rowSelectable && !hideRowSelectionCheckbox) {
            <ng-container matColumnDef="MtxGridCheckboxColumnDef">
              <th mat-header-cell *matHeaderCellDef class="mtx-grid-checkbox-cell">
                @if (multiSelectable) {
                  <mat-checkbox
                    [checked]="rowSelection.hasValue() && _isAllSelected()"
                    [indeterminate]="rowSelection.hasValue() && !_isAllSelected()"
                    (change)="$event ? _toggleMasterCheckbox() : null">
                  </mat-checkbox>
                }
              </th>
              <td mat-cell *matCellDef="let row; let index = index; let dataIndex = dataIndex;"
                class="mtx-grid-checkbox-cell">
                @if (!(rowSelectionFormatter.hideCheckbox && rowSelectionFormatter.hideCheckbox(row, _getIndex(index, dataIndex)))) {
                  <mat-checkbox
                    [disabled]="rowSelectionFormatter.disabled && rowSelectionFormatter.disabled(row, _getIndex(index, dataIndex))"
                    [checked]="rowSelection.isSelected(row)"
                    (click)="$event.stopPropagation()"
                    (change)="$event ? _toggleNormalCheckbox(row) : null">
                  </mat-checkbox>
                }
              </td>
              <td mat-footer-cell *matFooterCellDef class="mtx-grid-checkbox-cell"></td>
            </ng-container>
          }
          @for (col of columns; track col.field) {
            <ng-container [matColumnDef]="col.field"
              [sticky]="col.pinned==='left'" [stickyEnd]="col.pinned==='right'">
              <th mat-header-cell *matHeaderCellDef
                [class]="col | colClass"
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style.width]="col.width"
                [style.min-width]="col.width"
                [style.left]="col.left"
                [style.right]="col.right">
                <div class="mat-header-cell-inner">
                  @if (headerTemplate | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(headerTemplate)"
                      [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
                    </ng-template>
                  } @else {
                    @if ($any(headerTemplate)?.[col.field] | isTemplateRef) {
                      <ng-template [ngTemplateOutlet]="$any(headerTemplate)[col.field]"
                        [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
                      </ng-template>
                    } @else {
                      <div [mat-sort-header]="col.sortProp?.id || col.field"
                        [disabled]="!col.sortable"
                        [disableClear]="col.sortProp?.disableClear ?? sortDisableClear"
                        [arrowPosition]="col.sortProp?.arrowPosition!"
                        [start]="col.sortProp?.start!">
                        @if (col.showExpand) {
                          <span class="mtx-grid-expansion-placeholder"></span>
                        }
                        <span>{{col.header | toObservable | async}}</span>
                        @if (col.sortable) {
                          <svg class="mtx-grid-icon mat-sort-header-icon" viewBox="0 0 24 24"
                            width="24px" height="24px" fill="currentColor" focusable="false">
                            <path d="M3,13H15V11H3M3,6V8H21V6M3,18H9V16H3V18Z" />
                          </svg>
                        }
                      </div>
                      <ng-template [ngTemplateOutlet]="headerExtraTplBase"
                        [ngTemplateOutletContext]="{ $implicit: headerExtraTemplate, colDef: col }">
                      </ng-template>
                    }
                  }
                </div>
              </th>
              <td mat-cell *matCellDef="let row; let index = index; let dataIndex = dataIndex;"
                [class]="col | colClass: row: rowChangeRecord: rowChangeRecord?.currentValue"
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style.width]="col.width"
                [style.min-width]="col.width"
                [style.left]="col.left"
                [style.right]="col.right"
                mtx-grid-selectable-cell [cellSelectable]="cellSelectable"
                (cellSelectedChange)="_selectCell($event, row, col)">
                @if (cellTemplate | isTemplateRef) {
                  <ng-template [ngTemplateOutlet]="$any(cellTemplate)"
                    [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                  </ng-template>
                } @else {
                  @if ($any(cellTemplate)?.[col.field] | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(cellTemplate)[col.field]"
                      [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                    </ng-template>
                  } @else {
                    @if (col.cellTemplate) {
                      <ng-template
                        [ngTemplateOutlet]="col.cellTemplate!"
                        [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                      </ng-template>
                    } @else {
                      @if (col.showExpand) {
                        <button class="mtx-grid-row-expand-button"
                          mat-icon-button mtx-grid-expansion-toggle type="button"
                          [(opened)]="expansionRowStates[dataIndex].expanded"
                          (toggleChange)="_onExpansionChange($event, row, col, dataIndex);">
                          <svg class="mtx-grid-icon mtx-grid-row-expand-icon" viewBox="0 0 24 24"
                            width="24px" height="24px" fill="currentColor" focusable="false">
                            <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" />
                          </svg>
                        </button>
                      }
                      <mtx-grid-cell [rowData]="row" [colDef]="col" [placeholder]="emptyValuePlaceholder"
                        (rowDataChange)="_onRowDataChange($event)"></mtx-grid-cell>
                    }
                  }
                }
              </td>
              <td mat-footer-cell *matFooterCellDef
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style.width]="col.width"
                [style.min-width]="col.width"
                [style.left]="col.left"
                [style.right]="col.right">
                @if (col.showExpand) {
                  <span class="mtx-grid-expansion-placeholder"></span>
                }
                @if (summaryTemplate | isTemplateRef) {
                  <ng-template [ngTemplateOutlet]="$any(summaryTemplate)"
                    [ngTemplateOutletContext]="{ $implicit: col, colDef: col, data: data }">
                  </ng-template>
                } @else {
                  @if ($any(summaryTemplate)?.[col.field] | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(summaryTemplate)[col.field]"
                      [ngTemplateOutletContext]="{ $implicit: _getColData(data, col), colData: _getColData(data, col), colDef: col }">
                    </ng-template>
                  } @else {
                    <mtx-grid-cell [summary]="true" [data]="data" [colDef]="col"
                      [placeholder]="emptyValuePlaceholder"></mtx-grid-cell>
                  }
                }
              </td>
            </ng-container>
          }
          @if (!useContentHeaderRowTemplate) {
            <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
          }
          @if (!useContentRowTemplate) {
            <tr mat-row
              *matRowDef="let row; let index = index; let dataIndex = dataIndex; columns: displayedColumns;"
              [class]="row | rowClass: index: dataIndex: rowClassFormatter"
              [class.selected]="rowSelection.isSelected(row)"
              (click)="_selectRow($event, row, _getIndex(index, dataIndex))"
              (contextmenu)="_contextmenu($event, row, _getIndex(index, dataIndex))">
            </tr>
          }
          @if (_whetherShowSummary) {
            <tr mat-footer-row *matFooterRowDef="displayedColumns; sticky: true"></tr>
          }
          @if (expandable) {
            <!-- Expanded Content Column - The expandable row is made up of this one column that spans across all columns -->
            <ng-container matColumnDef="MtxGridExpansionColumnDef">
              <td mat-cell *matCellDef="let row; let dataIndex = dataIndex"
                [attr.colspan]="displayedColumns.length">
                <div class="mtx-grid-expansion-detail-wrapper">
                  <div class="mtx-grid-expansion-detail">
                    <ng-template [ngTemplateOutlet]="expansionTemplate"
                      [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: dataIndex, expanded: expansionRowStates[dataIndex].expanded }">
                    </ng-template>
                  </div>
                </div>
              </td>
            </ng-container>
            <tr mat-row
              *matRowDef="let row; columns: ['MtxGridExpansionColumnDef']; let dataIndex = dataIndex"
              class="mtx-grid-expansion"
              [class]="expansionRowStates[dataIndex].expanded ? 'expanded' : 'collapsed'">
            </tr>
          }
        </table>
      } @else {
        <!-- TODO: Use flexbox-based mat-table -->
        <table mat-table
          columnResize
          [class.mat-table-hover]="rowHover"
          [class.mat-table-striped]="rowStriped"
          [class.mat-table-expandable]="expandable"
          [dataSource]="dataSource"
          [multiTemplateDataRows]="expandable"
          matSort
          [matSortActive]="sortActive"
          [matSortDirection]="sortDirection"
          [matSortDisableClear]="sortDisableClear"
          [matSortDisabled]="sortDisabled"
          [matSortStart]="sortStart"
          (matSortChange)="_onSortChange($event)"
          [trackBy]="trackBy">
          @if (rowSelectable && !hideRowSelectionCheckbox) {
            <ng-container matColumnDef="MtxGridCheckboxColumnDef">
              <th mat-header-cell *matHeaderCellDef class="mtx-grid-checkbox-cell">
                @if (multiSelectable) {
                  <mat-checkbox
                    [checked]="rowSelection.hasValue() && _isAllSelected()"
                    [indeterminate]="rowSelection.hasValue() && !_isAllSelected()"
                    (change)="$event ? _toggleMasterCheckbox() : null">
                  </mat-checkbox>
                }
              </th>
              <td mat-cell *matCellDef="let row; let index = index; let dataIndex = dataIndex;"
                class="mtx-grid-checkbox-cell">
                @if (!(rowSelectionFormatter.hideCheckbox && rowSelectionFormatter.hideCheckbox(row, _getIndex(index, dataIndex)))) {
                  <mat-checkbox
                    [disabled]="rowSelectionFormatter.disabled && rowSelectionFormatter.disabled(row, _getIndex(index, dataIndex))"
                    [checked]="rowSelection.isSelected(row)"
                    (click)="$event.stopPropagation()"
                    (change)="$event ? _toggleNormalCheckbox(row) : null">
                  </mat-checkbox>
                }
              </td>
              <td mat-footer-cell *matFooterCellDef class="mtx-grid-checkbox-cell"></td>
            </ng-container>
          }
          @for (col of columns; track col.field) {
            <ng-container [matColumnDef]="col.field"
              [sticky]="col.pinned==='left'" [stickyEnd]="col.pinned==='right'">
              <th mat-header-cell *matHeaderCellDef
                [class]="col | colClass"
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style.width]="col.width"
                [style.left]="col.left"
                [style.right]="col.right"
                [resizable]="col.resizable"
                [matResizableMinWidthPx]="col.minWidth"
                [matResizableMaxWidthPx]="col.maxWidth">
                <div class="mat-header-cell-inner">
                  @if (headerTemplate | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(headerTemplate)"
                      [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
                    </ng-template>
                  } @else {
                    @if ($any(headerTemplate)?.[col.field] | isTemplateRef) {
                      <ng-template [ngTemplateOutlet]="$any(headerTemplate)[col.field]"
                        [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
                      </ng-template>
                    } @else {
                      <div [mat-sort-header]="col.sortProp?.id || col.field"
                        [disabled]="!col.sortable"
                        [disableClear]="col.sortProp?.disableClear ?? sortDisableClear"
                        [arrowPosition]="col.sortProp?.arrowPosition!"
                        [start]="col.sortProp?.start!">
                        @if (col.showExpand) {
                          <span class="mtx-grid-expansion-placeholder"></span>
                        }
                        <span>{{col.header | toObservable | async}}</span>
                        @if (col.sortable) {
                          <svg class="mtx-grid-icon mat-sort-header-icon" viewBox="0 0 24 24"
                            width="24px" height="24px" fill="currentColor" focusable="false">
                            <path d="M3,13H15V11H3M3,6V8H21V6M3,18H9V16H3V18Z" />
                          </svg>
                        }
                      </div>
                      <ng-template [ngTemplateOutlet]="headerExtraTplBase"
                        [ngTemplateOutletContext]="{ $implicit: headerExtraTemplate, colDef: col }">
                      </ng-template>
                    }
                  }
                </div>
              </th>
              <td mat-cell *matCellDef="let row; let index = index; let dataIndex = dataIndex;"
                [class]="col | colClass: row: rowChangeRecord :rowChangeRecord?.currentValue"
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style.width]="col.width"
                [style.left]="col.left"
                [style.right]="col.right"
                mtx-grid-selectable-cell [cellSelectable]="cellSelectable"
                (cellSelectedChange)="_selectCell($event, row, col)">
                @if (cellTemplate | isTemplateRef) {
                  <ng-template [ngTemplateOutlet]="$any(cellTemplate)"
                    [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                  </ng-template>
                } @else {
                  @if ($any(cellTemplate)?.[col.field] | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(cellTemplate)[col.field]"
                      [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                    </ng-template>
                  } @else {
                    @if (col.cellTemplate) {
                      <ng-template
                        [ngTemplateOutlet]="col.cellTemplate!"
                        [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: _getIndex(index, dataIndex), colDef: col }">
                      </ng-template>
                    } @else {
                      @if (col.showExpand) {
                        <button class="mtx-grid-row-expand-button"
                          mat-icon-button mtx-grid-expansion-toggle type="button"
                          [(opened)]="expansionRowStates[dataIndex].expanded"
                          (toggleChange)="_onExpansionChange($event, row, col, dataIndex);">
                          <svg class="mtx-grid-icon mtx-grid-row-expand-icon" viewBox="0 0 24 24"
                            width="24px" height="24px" fill="currentColor" focusable="false">
                            <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" />
                          </svg>
                        </button>
                      }
                      <mtx-grid-cell [rowData]="row" [colDef]="col" [placeholder]="emptyValuePlaceholder"
                        (rowDataChange)="_onRowDataChange($event)"></mtx-grid-cell>
                    }
                  }
                }
              </td>
              <td mat-footer-cell *matFooterCellDef
                [class.mat-table-sticky-left]="col.pinned === 'left'"
                [class.mat-table-sticky-right]="col.pinned === 'right'"
                [style.width]="col.width"
                [style.left]="col.left"
                [style.right]="col.right">
                @if (col.showExpand) {
                  <span class="mtx-grid-expansion-placeholder"></span>
                }
                @if (summaryTemplate | isTemplateRef) {
                  <ng-template [ngTemplateOutlet]="$any(summaryTemplate)"
                    [ngTemplateOutletContext]="{ $implicit: col, colDef: col, data: data }">
                  </ng-template>
                } @else {
                  @if ($any(summaryTemplate)?.[col.field] | isTemplateRef) {
                    <ng-template [ngTemplateOutlet]="$any(summaryTemplate)[col.field]"
                      [ngTemplateOutletContext]="{ $implicit: _getColData(data, col), colData: _getColData(data, col), colDef: col }">
                    </ng-template>
                  } @else {
                    <mtx-grid-cell [summary]="true" [data]="data" [colDef]="col"
                      [placeholder]="emptyValuePlaceholder"></mtx-grid-cell>
                  }
                }
              </td>
            </ng-container>
          }
          @if (!useContentHeaderRowTemplate) {
            <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
          }
          @if (!useContentRowTemplate) {
            <tr mat-row
              *matRowDef="let row; let index = index; let dataIndex = dataIndex; columns: displayedColumns;"
              [class]="row | rowClass: index: dataIndex: rowClassFormatter"
              [class.selected]="rowSelection.isSelected(row)"
              (click)="_selectRow($event, row, _getIndex(index, dataIndex))"
              (contextmenu)="_contextmenu($event, row, _getIndex(index, dataIndex))">
            </tr>
          }
          @if (_whetherShowSummary) {
            <tr mat-footer-row *matFooterRowDef="displayedColumns; sticky: true"></tr>
          }
          @if (expandable) {
            <!-- Expanded Content Column - The expandable row is made up of this one column that spans across all columns -->
            <ng-container matColumnDef="MtxGridExpansionColumnDef">
              <td mat-cell *matCellDef="let row; let dataIndex = dataIndex"
                [attr.colspan]="displayedColumns.length">
                <div class="mtx-grid-expansion-detail-wrapper">
                  <div class="mtx-grid-expansion-detail">
                    <ng-template [ngTemplateOutlet]="expansionTemplate"
                      [ngTemplateOutletContext]="{ $implicit: row, rowData: row, index: dataIndex, expanded: expansionRowStates[dataIndex].expanded }">
                    </ng-template>
                  </div>
                </div>
              </td>
            </ng-container>
            <tr mat-row
              *matRowDef="let row; columns: ['MtxGridExpansionColumnDef']; let dataIndex = dataIndex"
              class="mtx-grid-expansion"
              [class]="expansionRowStates[dataIndex].expanded ? 'expanded' : 'collapsed'">
            </tr>
          }
        </table>
      }
    </div>

    <!-- No result -->
    @if (_hasNoResult) {
      <div class="mtx-grid-no-result">
        @if (noResultTemplate) {
          <ng-template [ngTemplateOutlet]="noResultTemplate"></ng-template>
        } @else {
          {{noResultText}}
        }
      </div>
    }
  </div>

  <!-- Tool sidebar -->
  @if (showSidebar) {
    <div class="mtx-grid-sidebar">
      @if (sidebarTemplate) {
        <ng-template [ngTemplateOutlet]="sidebarTemplate"></ng-template>
      }
    </div>
  }
</div>

<div class="mtx-grid-footer">
  <!-- Status Bar -->
  @if (showStatusbar) {
    <div class="mtx-grid-statusbar">
      @if (statusbarTemplate) {
        <ng-template [ngTemplateOutlet]="statusbarTemplate"></ng-template>
      }
    </div>
  }

  <!-- Pagination -->
  <div class="mtx-grid-pagination">
    @if (paginationTemplate) {
      <ng-template [ngTemplateOutlet]="paginationTemplate"></ng-template>
    } @else {
      <mat-paginator [class.mat-paginator-hidden]="!showPaginator"
        [showFirstLastButtons]="showFirstLastButtons"
        [length]="length"
        [pageIndex]="pageIndex"
        [pageSize]="pageSize"
        [pageSizeOptions]="pageSizeOptions"
        [hidePageSize]="hidePageSize"
        (page)="_onPage($event)"
        [disabled]="pageDisabled">
      </mat-paginator>
    }
  </div>
</div>

<!-- Header template for extra content -->
<ng-template #headerExtraTplBase let-headerExtraTemplate let-col="colDef">
  @if (headerExtraTemplate | isTemplateRef) {
    <ng-template [ngTemplateOutlet]="headerExtraTemplate"
      [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
    </ng-template>
  } @else {
    @if ($any(headerExtraTemplate)?.[col.field] | isTemplateRef) {
      <ng-template [ngTemplateOutlet]="headerExtraTemplate[col.field]"
        [ngTemplateOutletContext]="{ $implicit: col, colDef: col }">
      </ng-template>
    }
  }
</ng-template>
`,
      styles: ['.mat-column-resize-table.cdk-column-resize-with-resized-column{table-layout:fixed}.mat-column-resize-flex .mat-mdc-header-cell,.mat-column-resize-flex .mat-mdc-cell{box-sizing:border-box;min-width:32px}.mat-mdc-header-cell{position:relative}.mat-resizable{box-sizing:border-box}.mat-mdc-header-cell:not(.mat-resizable):after,.mat-resizable-handle{position:absolute;bottom:0;top:0;right:0;width:1px;background:transparent;transition:background .3s cubic-bezier(.55,0,.55,.2)}.mat-mdc-header-cell:not(.mat-resizable):after{content:""}[dir=rtl] .mat-mdc-header-cell:not(.mat-resizable):after,[dir=rtl] .mat-resizable-handle{left:0;right:auto}[dir=rtl] .mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-header-cell,[dir=rtl] .mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-mdc-header-cell{border-left:none}.mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-mdc-header-cell{border-right:none}.mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-mdc-header-cell:not(.mat-resizable):after{background-color:var(--mtx-grid-resizable-handle-disabled-background-color, var(--mat-sys-outline-variant))}.mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-resizable-handle{background-color:var(--mtx-grid-resizable-handle-hover-background-color, var(--mat-sys-primary))}.mat-resizable.cdk-resizable-overlay-thumb-active>.mat-resizable-handle{opacity:0;transition:none}.mat-resizable-handle:focus,.mat-mdc-header-row.cdk-column-resize-hover-or-active .mat-resizable-handle:focus{outline:none;background-color:var(--mtx-grid-resizable-handle-active-background-color, var(--mat-sys-primary))}.mat-column-resize-overlay-thumb{background:transparent;cursor:col-resize;width:100%;height:100%;transition:background .3s cubic-bezier(.55,0,.55,.2);-webkit-user-select:none;user-select:none}.mat-column-resize-overlay-thumb:active{will-change:transform;background:linear-gradient(90deg,transparent,transparent 7px,var(--mtx-grid-resizable-handle-active-background-color, var(--mat-sys-primary)) 7px,var(--mtx-grid-resizable-handle-active-background-color, var(--mat-sys-primary)) 9px,transparent 9px,transparent)}.mat-column-resize-overlay-thumb:active .mat-column-resize-overlay-thumb-top{background:linear-gradient(90deg,transparent,transparent 4px,var(--mtx-grid-resizable-handle-active-background-color, var(--mat-sys-primary)) 4px,var(--mtx-grid-resizable-handle-active-background-color, var(--mat-sys-primary)) 12px,transparent 12px,transparent)}.mat-column-resize-overlay-thumb-top{width:100%}.mtx-grid{position:relative;display:flex;flex-direction:column;width:100%;overflow:hidden;border:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant));border-radius:var(--mtx-grid-container-shape, var(--mat-sys-corner-medium))}.mtx-grid .mat-mdc-table{--mat-table-row-item-outline-color: var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}.mtx-grid .mat-mdc-table.mat-table-striped .mat-row-odd{background-color:var(--mtx-grid-table-row-striped-background-color, var(--mat-sys-surface-container))}.mtx-grid .mat-mdc-table.mat-table-hover .mat-mdc-row:hover{background-color:var(--mtx-grid-table-row-hover-background-color, var(--mat-sys-secondary-container))}.mtx-grid .mat-mdc-table.mat-table-hover .mat-mdc-row.selected:hover{background-color:var(--mtx-grid-table-row-selected-hover-background-color, var(--mat-sys-primary-container))}.mtx-grid .mat-mdc-table .mat-mdc-row.selected{background-color:var(--mtx-grid-table-row-selected-background-color, var(--mat-sys-secondary-container))}.mtx-grid .mat-mdc-table .mat-mdc-cell.selected{box-shadow:inset 0 0 0 1px var(--mtx-grid-table-cell-selected-outline-color, var(--mat-sys-primary))}.mtx-grid .mat-table-container{overflow:auto}.mtx-grid .mat-table-container.mat-table-with-data{flex:1}.mtx-grid .mat-mdc-table:not(.mat-column-resize-table){min-width:100%;border-collapse:separate}.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-header-cell:not(.mtx-grid-checkbox-cell),.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-footer-cell:not(.mtx-grid-checkbox-cell),.mtx-grid .mat-mdc-table:not(.mat-column-resize-table) .mat-mdc-cell:not(.mtx-grid-checkbox-cell){min-width:var(--mtx-grid-table-cell-min-width, 80px)}.mtx-grid .mat-table-sticky-left{border-right:1px solid var(--mat-table-row-item-outline-color)}[dir=rtl] .mtx-grid .mat-table-sticky-left{border-right-width:0;border-left:1px solid var(--mat-table-row-item-outline-color)}.mtx-grid .mat-table-sticky-right{border-left:1px solid var(--mat-table-row-item-outline-color)}[dir=rtl] .mtx-grid .mat-table-sticky-right{border-left-width:0;border-right:1px solid var(--mat-table-row-item-outline-color)}.mtx-grid .mat-mdc-footer-cell{border-top:1px solid var(--mat-table-row-item-outline-color);background-color:var(--mtx-grid-table-footer-background-color, var(--mat-sys-surface-container))}.mtx-grid .mat-mdc-row.mtx-grid-expansion{height:0;overflow:hidden}.mtx-grid .mat-mdc-row.mtx-grid-expansion .mat-mdc-cell{padding-top:0;padding-bottom:0}.mtx-grid .mat-mdc-row.mtx-grid-expansion.collapsed .mat-mdc-cell{border-bottom-width:0}.mtx-grid .mat-sort-header-icon{margin-left:4px}[dir=rtl] .mtx-grid .mat-sort-header-icon{margin-left:0;margin-right:4px}.mtx-grid .mat-header-cell-inner{display:inline-flex;align-items:center;vertical-align:middle}.mtx-grid .mat-mdc-paginator{border-top:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant));border-bottom-left-radius:var(--mtx-grid-container-shape, var(--mat-sys-corner-medium));border-bottom-right-radius:var(--mtx-grid-container-shape, var(--mat-sys-corner-medium))}.mtx-grid .mat-paginator-hidden{display:none}.mtx-grid .mtx-grid-checkbox-cell{width:60px;min-width:60px;padding:0 calc((60px - var(--mat-checkbox-state-layer-size, 40px)) / 2)}.mtx-grid-progress{position:absolute;top:0;z-index:120;width:100%}.mtx-grid-toolbar{display:flex;justify-content:space-between;align-items:center;min-height:var(--mat-table-header-container-height, 56px);padding:8px;box-sizing:border-box;border-bottom:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}.mtx-grid-toolbar-content{flex:1;width:0;padding:0 8px}.mtx-grid-layout{display:flex;flex:1 1 auto;overflow:auto}.mtx-grid-content{flex-direction:column;width:0}.mtx-grid-sidebar{max-width:50%;border-left:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}[dir=rtl] .mtx-grid-sidebar{border-left-width:0;border-right:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}.mtx-grid-footer{position:relative;z-index:1}.mtx-grid-statusbar{display:flex;align-items:center;min-height:var(--mat-table-header-container-height, 56px);padding:8px;box-sizing:border-box;border-top:1px solid var(--mtx-grid-outline-color, var(--mat-sys-outline-variant))}.mtx-grid-no-result{display:flex;justify-content:center;align-items:center;flex:1;min-height:150px}.mtx-grid-expansion-placeholder{display:inline-block;vertical-align:middle;width:var(--mat-icon-button-state-layer-size, var(--mtx-grid-row-expand-button-size, 40px));height:var(--mat-icon-button-state-layer-size, var(--mtx-grid-row-expand-button-size, 40px))}.mtx-grid-expansion-detail-wrapper{display:grid;grid-template-rows:0fr;grid-template-columns:100%;padding:0;overflow:hidden}.mtx-grid-expansion.expanded .mtx-grid-expansion-detail-wrapper{grid-template-rows:1fr;padding:calc((var(--mat-table-row-item-container-height, 52px) - 20px) / 2) 0}.mtx-grid-expansion-detail{min-height:0}.mtx-grid-animations-enabled .mtx-grid-expansion-detail-wrapper{transition:all 225ms cubic-bezier(.4,0,.2,1)}.mtx-grid-row-expand-button.expanded .mtx-grid-row-expand-icon{transform:rotate(90deg)}.mtx-grid-row-expand-button.mat-mdc-icon-button,.mtx-grid-row-expand-button+mtx-grid-cell{vertical-align:middle}\n']
    }]
  }], null, {
    table: [{
      type: ViewChild,
      args: [MatTable]
    }],
    paginator: [{
      type: ViewChild,
      args: [MatPaginator]
    }],
    sort: [{
      type: ViewChild,
      args: [MatSort]
    }],
    rowDefs: [{
      type: ContentChildren,
      args: [MatRowDef]
    }],
    headerRowDefs: [{
      type: ContentChildren,
      args: [MatHeaderRowDef]
    }],
    footerRowDefs: [{
      type: ContentChildren,
      args: [MatFooterRow]
    }],
    columnResize: [{
      type: ViewChild,
      args: [ColumnResize]
    }],
    columnMenu: [{
      type: ViewChild,
      args: [MtxGridColumnMenu]
    }],
    tableContainer: [{
      type: ViewChild,
      args: ["tableContainer"]
    }],
    displayedColumns: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    length: [{
      type: Input
    }],
    loading: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    trackBy: [{
      type: Input
    }],
    columnResizable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    emptyValuePlaceholder: [{
      type: Input
    }],
    pageOnFront: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showPaginator: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    pageDisabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showFirstLastButtons: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    pageIndex: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    pageSizeOptions: [{
      type: Input
    }],
    hidePageSize: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    page: [{
      type: Output
    }],
    paginationTemplate: [{
      type: Input
    }],
    sortOnFront: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    sortActive: [{
      type: Input
    }],
    sortDirection: [{
      type: Input
    }],
    sortDisableClear: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    sortDisabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    sortStart: [{
      type: Input
    }],
    sortChange: [{
      type: Output
    }],
    rowHover: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    rowStriped: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    rowClick: [{
      type: Output
    }],
    rowContextMenu: [{
      type: Output
    }],
    expandable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    expansionTemplate: [{
      type: Input
    }],
    expansionChange: [{
      type: Output
    }],
    multiSelectable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    multiSelectionWithClick: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    rowSelectable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    hideRowSelectionCheckbox: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disableRowClickSelection: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    rowSelectionFormatter: [{
      type: Input
    }],
    rowClassFormatter: [{
      type: Input
    }],
    rowSelected: [{
      type: Input
    }],
    rowSelectedChange: [{
      type: Output
    }],
    cellSelectable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    cellSelectedChange: [{
      type: Output
    }],
    showToolbar: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    toolbarTitle: [{
      type: Input
    }],
    toolbarTemplate: [{
      type: Input
    }],
    columnHideable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnHideableChecked: [{
      type: Input
    }],
    columnSortable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnPinnable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnChange: [{
      type: Output
    }],
    columnPinOptions: [{
      type: Input
    }],
    showColumnMenuButton: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnMenuButtonText: [{
      type: Input
    }],
    columnMenuButtonType: [{
      type: Input
    }],
    columnMenuButtonColor: [{
      type: Input
    }],
    columnMenuButtonClass: [{
      type: Input
    }],
    columnMenuButtonIcon: [{
      type: Input
    }],
    columnMenuButtonFontIcon: [{
      type: Input
    }],
    columnMenuButtonSvgIcon: [{
      type: Input
    }],
    showColumnMenuHeader: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnMenuHeaderText: [{
      type: Input
    }],
    columnMenuHeaderTemplate: [{
      type: Input
    }],
    showColumnMenuFooter: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    columnMenuFooterText: [{
      type: Input
    }],
    columnMenuFooterTemplate: [{
      type: Input
    }],
    noResultText: [{
      type: Input
    }],
    noResultTemplate: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    headerExtraTemplate: [{
      type: Input
    }],
    cellTemplate: [{
      type: Input
    }],
    useContentRowTemplate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    useContentHeaderRowTemplate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    useContentFooterRowTemplate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showSummary: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    summaryTemplate: [{
      type: Input
    }],
    showSidebar: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    sidebarTemplate: [{
      type: Input
    }],
    showStatusbar: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    statusbarTemplate: [{
      type: Input
    }]
  });
})();
var _MtxGridModule = class _MtxGridModule {
};
_MtxGridModule.ɵfac = function MtxGridModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MtxGridModule)();
};
_MtxGridModule.ɵmod = ɵɵdefineNgModule({
  type: _MtxGridModule,
  imports: [CommonModule, FormsModule, MatTableModule, MatSortModule, MatPaginatorModule, MatCheckboxModule, MatButtonModule, MatProgressBarModule, MatChipsModule, MatTooltipModule, MatBadgeModule, MatIconModule, MatSelectModule, MatFormFieldModule, MatMenuModule, DragDropModule, MtxDialogModule, MtxPipesModule, MatColumnResizeModule, MtxGrid, MtxGridCell, MtxGridColumnMenu, MtxGridExpansionToggle, MtxGridSelectableCell, MtxGridMenu, MtxGridRowClassPipe, MtxGridColClassPipe, MtxGridCellActionsPipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe, MtxGridCellActionDisablePipe, MtxGridCellSummaryPipe],
  exports: [MatColumnResizeModule, MtxGrid, MtxGridCell, MtxGridColumnMenu, MtxGridExpansionToggle, MtxGridSelectableCell, MtxGridMenu, MtxGridRowClassPipe, MtxGridColClassPipe, MtxGridCellActionsPipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe, MtxGridCellActionDisablePipe, MtxGridCellSummaryPipe]
});
_MtxGridModule.ɵinj = ɵɵdefineInjector({
  providers: [MtxGridUtils],
  imports: [CommonModule, FormsModule, MatTableModule, MatSortModule, MatPaginatorModule, MatCheckboxModule, MatButtonModule, MatProgressBarModule, MatChipsModule, MatTooltipModule, MatBadgeModule, MatIconModule, MatSelectModule, MatFormFieldModule, MatMenuModule, DragDropModule, MtxDialogModule, MtxPipesModule, MatColumnResizeModule, MtxGrid, MtxGridCell, MtxGridColumnMenu, MtxGridMenu, MatColumnResizeModule]
});
var MtxGridModule = _MtxGridModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MtxGridModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, MatTableModule, MatSortModule, MatPaginatorModule, MatCheckboxModule, MatButtonModule, MatProgressBarModule, MatChipsModule, MatTooltipModule, MatBadgeModule, MatIconModule, MatSelectModule, MatFormFieldModule, MatMenuModule, DragDropModule, MtxDialogModule, MtxPipesModule, MatColumnResizeModule, MtxGrid, MtxGridCell, MtxGridColumnMenu, MtxGridExpansionToggle, MtxGridSelectableCell, MtxGridMenu, MtxGridRowClassPipe, MtxGridColClassPipe, MtxGridCellActionsPipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe, MtxGridCellActionDisablePipe, MtxGridCellSummaryPipe],
      exports: [MatColumnResizeModule, MtxGrid, MtxGridCell, MtxGridColumnMenu, MtxGridExpansionToggle, MtxGridSelectableCell, MtxGridMenu, MtxGridRowClassPipe, MtxGridColClassPipe, MtxGridCellActionsPipe, MtxGridCellActionTooltipPipe, MtxGridCellActionBadgePipe, MtxGridCellActionDisablePipe, MtxGridCellSummaryPipe],
      providers: [MtxGridUtils]
    }]
  }], null, null);
})();
export {
  FLEX_RESIZE_STRATEGY_PROVIDER2 as FLEX_RESIZE_STRATEGY_PROVIDER,
  MTX_GRID_DEFAULT_OPTIONS,
  MatColumnResize,
  MatColumnResizeCommonModule,
  MatColumnResizeFlex,
  MatColumnResizeModule,
  MatColumnResizeOverlayHandle,
  MatFlexTableResizeStrategy,
  MatResizable,
  MtxGrid,
  MtxGridCell,
  MtxGridCellActionBadgePipe,
  MtxGridCellActionDisablePipe,
  MtxGridCellActionTooltipPipe,
  MtxGridCellActionsPipe,
  MtxGridCellSummaryPipe,
  MtxGridColClassPipe,
  MtxGridColumnMenu,
  MtxGridExpansionToggle,
  MtxGridMenu,
  MtxGridModule,
  MtxGridRowClassPipe,
  MtxGridSelectableCell,
  MtxGridUtils,
  TABLE_LAYOUT_FIXED_RESIZE_STRATEGY_PROVIDER
};
/*! Bundled license information:

@ng-matero/extensions/fesm2022/mtxColumnResize.mjs:
@ng-matero/extensions/fesm2022/mtxGrid.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)
*/
//# sourceMappingURL=@ng-matero_extensions_grid.js.map
